\documentclass{report}

\usepackage{epigraph}
\usepackage{colortbl}
\usepackage{xspace}
\usepackage{listings}
\usepackage{relsize}

\input{darais-latex-imports}
\input{darais-latex-macros}

\newcommand{\lang}{Allyn\xspace}
\newcommand{\mpc}{\ensuremath{\lambda_{\mathrm{MPC}}}\xspace}
\newcommand{\obliv}{\ensuremath{\lambda_{\mathrm{Obliv}}}\xspace}

\newcommand{\ins}[1]{\textcolor{red}{Ian: #1}}

%%% Macros for MPC
\newcommand{\alice}{B‚∏®‚ÄπAlice‚Ä∫B‚∏©\xspace}
\newcommand{\bob}{C‚∏®‚ÄπBob‚Ä∫C‚∏©\xspace}

\newcommand{\alices}[1]{B‚∏®#1‚∏§A‚∏•B‚∏©}
\newcommand{\bobs}[1]{C‚∏®#1‚∏§B‚∏•C‚∏©}

\newcommand{\aliceSec}{\alices{s}\xspace}
\newcommand{\bobSec}{\bobs{s}\xspace}

\newcommand{\aliceSh}[1]{\alices{‚åä#1‚åã}}
\newcommand{\bobSh}[1]{\bobs{‚åä#1‚åã}}

\newcommand{\opaque}{A‚∏®‚òÖA‚∏©\xspace}
%%%

\definecolor{implColor}{HTML}{EA9999}
\definecolor{theoryColor}{HTML}{A4C2F4}

\begin{document}

\title{A Programming Language for Obliviousness and Secure Computation}

\author{Ian Sweet \\
  \emph{University of Maryland, College Park} \\
  \emph{ins@cs.umd.edu}}

\date{}

\maketitle

\begin{abstract}
  \emph{Secure Multiparty Computation (MPC)} and \emph{Oblivious RAM} (ORAM) have emerged as promising approaches to
  high-confidentiality computation. Traditionally, MPC programs do not allow secrets to be used as indexes to dynamically
  allocated memory. This precludes, for example, a secure binary search in which the element being accessed is considered secret.
  This restriction is relaxed by using ORAM inside of the secure computation. Unfortunately, existing languages for MPC typically
  support ORAM by ``baking it in'' to the language as a trusted primitive. We propose the design and implementation of a language
  for MPC with \emph{application-level support} for ORAM with an associated \emph{proof of security}.
\end{abstract}

\chapter{Introduction}

\epigraph{It seems like everywhere I go \\
          The more I see, the less I know}{
            Michael Franti \& Spearhead \\
            \emph{Say Hey I Love You}}

If our adversaries were more like Michael Franti then we wouldn't need to concern ourselves with confidentiality.
Unfortunately, that isn't the world we live in. \emph{Secure Multiparty Computation (MPC)} and \emph{Oblivious RAM} (ORAM)
have emerged as promising approaches to high-confidentiality computation. An MPC program allows mutually distrustful
parties to compute over their secret inputs while guaranteeing that they learn nothing more than the result.
Traditionally, these programs do not allow secrets to be used as indexes to dynamically allocated memory.
This precludes, for example, a secure binary search in which the element being accessed is considered secret.
This restriction is relaxed by using ORAM inside of the secure computation. ORAM is an abstract data type with a
RAM-like interface which prevents information leaks through the (physical) memory access pattern side-channel.
So, how do existing MPC languages integrate ORAM? Well, some side-step the issue by relying on applications
to implement ORAM as a library. This has the benefit of empowering the programmer but the detriment of
giving up security guarantees; a buggy ORAM could leak information about secrets accidentally.
Other MPC languages ``bake in'' ORAM as a trusted primitive. This has the converse effect of guaranteeing
security\footnote{Of course, this assumes that the trusted primitive is correct (usually) without a machine-checked proof}
but removing the programmer's ability to choose the ORAM implementation best suited to their application.
What if we could empower programmers to \emph{implement ORAM as a library} and also automatically
\emph{verify that they aren't accidentally leaking their secrets}?

\paragraph{Hypothesis} Motivated by the observation of the previous paragraph, this proposal presents a plan
for the design and implementation of an MPC language, \lang, with \emph{application-level support} for ORAM and an
\emph{automatic proof of security} for all programs written in the language. How will we verify that the hypothesis is correct?
First, we will develop a formal model of \lang and prove that it enjoys security.
Second, we will implement \lang and show that it admits modern ORAM schemes.

\section{Proposed Work}

Tasks in \colorbox{implColor}{red} require adding additional functionality to the existing Haskell implementation of \mpc.
Tasks in \colorbox{theoryColor}{blue} require adapting the formal metatheory of \mpc. \\

\begin{tabular}{|p{.30\textwidth}|p{.30\textwidth}|p{.30\textwidth}|}
  \hline
  \textbf{Task} & \textbf{Description} & \textbf{Estimated Time of Completion} \\
  \hline
  \rowcolor{implColor}
  Case Studies:
  \begin{itemize}
  \item Trivial ORAM
  \item Tree ORAM(s)
  \item Recursive ORAM
  \end{itemize}    & Implement case studies in \lang;
  show that they are functionally correct and typecheck & 10/07/2020 (~2 weeks)  \\ \hline
  \rowcolor{implColor}
  Type Checker     & Implement the type checker for \lang                  & 11/07/2020 (~1 month)  \\ \hline
  \rowcolor{implColor}
  MPC Interpreter  & Implement an EMP MPC backend for \lang                & 01/07/2021 (~2 months) \\ \hline
  \rowcolor{theoryColor}
  Static Semantics & \lang is \mpc + \obliv                                & 03/07/2021 (~2 months) \\ \hline
  \rowcolor{theoryColor}
  PMTO\%           & Prove \lang satisfies PMTO\%                          & 05/07/2021 (~2 months) \\ \hline
  \rowcolor{theoryColor}
  Type Soundness   & Prove \lang satisfies Type Soundness                  & 05/14/2021 (~1 week)   \\ \hline
  \rowcolor{theoryColor}
  Simulation       & Prove \lang satisfies Simulation                      & 05/21/2021 (~1 week)   \\ \hline
\end{tabular}


\chapter{Background}
\epigraph{Trust in me in all you do \\
          Have the faith I have in you \\
          Love will see us through \\
          If only you trust in me}{
            Etta James \\
            \emph{Trust in Me}}

For those committe members who aren't (yet) totally jazzed about MPC and ORAM, this one goes out to you.

\section{Secure Multiparty Computation}

The mission of Secure Multiparty Computation (MPC) is to allow many parties who don't trust each
other to compute over their private inputs while only learning the result of the public output.
In this proposal, we will only concern ourselves with the honest-but-curious threat model which
assumes that parties must obey the protocol but may attempt to passively learn information about the secrets of others.

\subsection{Overview}

MPC works by allowing a secret, in cleartext, to be split up into many ``shares'' which are considered ciphertext
and therefore may be safely distributed to other parties and recombined later. More specifically, shares have the following properties:
\begin{enumerate}
\item Shares can be combined to reveal the original cleartext secret.
\item A share does not reveal any information about the secret.
\item Parties can cooperate to compute over shares. For example, being able to create shares of boolean values
  and compute XOR and AND over those shares forms a complete basis for computation. Primitives such as addition,
  comparison, etc. can be built from these boolean operations.
\end{enumerate}

The languages discussed in this proposal are agnostic to the underlying MPC protocol. We only require that the underlying MPC protocol
have the properties listed above. For the purposes of exposition, however, we choose to use the GMW protocol [cite] as a
representative for MPC protocols in general.

In GMW, the secrets being shared are booleans. To represent integers with arithmetic, comparison, etc. we use a two's
complement representation. For example, a digital circuit with only XOR and AND gates can be used to half adders,
full-adders, and ripple-carry adders. A party \alice can generate her share of her (boolean) secret \aliceSec by
generating a random number:

M‚ÅÖ
\aliceSh{\aliceSec} ‚Üê ùí∞(‚ù¥0,1‚ùµ)
M‚ÅÜ

The notation ‚∏®‚åäv‚åã‚∏§P‚∏•‚∏© indicates that this is ‚∏®P‚∏©'s share of the value ‚∏®v‚∏©. Then, \alice generates \bob's share of \aliceSec
as the XOR of her share with the original secret:

M‚ÅÖ
\bobSh{\aliceSec} ‚Üê \aliceSh{\aliceSec} ‚äï \aliceSec
M‚ÅÜ

At this point, there are a few important things to notice. First, \bob's share is effectively another random number.
As long as he never sees \aliceSh{\aliceSec} he can't distinguish his share \bobSh{\aliceSec} from a fresh, uniform
boolean value. This establishes property (2) of MPC above. Second, XOR has the following properties:

\begin{fact}[‚∏®‚äï‚∏©-Inverse]
\label{xor-inverse}
  ‚∏®‚àÄ b ‚àà ùîπ‚ê£.‚ê£b ‚äï b = 0‚∏©
\end{fact}

\begin{fact}[‚∏®‚äï‚∏©-Identity]
\label{xor-identity}
  ‚∏®‚àÄ b ‚àà ùîπ‚ê£.‚ê£b ‚äï 0 = 0 ‚äï b = b‚∏©
\end{fact}

These two properties ensure that the original secret, \aliceSec, can be recovered by XOR'ing the shares together:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚ßº=‚ßΩ \aliceSh{\aliceSec} ‚äï \aliceSh{\aliceSec} ‚äï \aliceSec & ‚ê†‚ü™[Definition of \bobSh{\aliceSec}]‚ü´
  A‚ÅÉ                                         ‚ßº=‚ßΩ 0 ‚äï \aliceSec & ‚ê†‚ü™[Fact~\ref{xor-inverse}]‚ü´
  A‚ÅÉ                                         ‚ßº=‚ßΩ \aliceSec & ‚ê†‚ü™[Fact~\ref{xor-identity}]‚ü´
  A‚ÅÜ
M‚ÅÜ

which establishes MPC property (1) above. Now, let's assume that \bob executes the same protocol to share his secret, \bobSec,
with \alice by splitting it into \aliceSh{\bobSec} and \bobSh{\bobSec}. So, at this point \alice has her shares of both secrets
and similarly for \bob. How can we accomplish property (3) of MPC? To compute ‚∏®\aliceSec ‚äï \bobSec‚∏© we can simply have \alice and \bob
evaluate the XOR of their shares independently:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{A‚∏® \aliceSec ‚äï \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \aliceSh{\aliceSec} ‚äï \aliceSh{\bobSec}
  A‚ÅÉ \bobSh{A‚∏® \aliceSec   ‚äï \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \bobSh{\aliceSec}   ‚äï \bobSh{\bobSec}
  A‚ÅÜ
M‚ÅÜ

Why does this work? Well, it's because XOR is associative:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec ‚äï \bobSec} ‚äï \bobSh{\aliceSec ‚äï \bobSec} ‚ßº=‚ßΩ
      (\aliceSh{\aliceSec} ‚äï \aliceSh{\bobSec}) ‚äï (\bobSh{\aliceSec} ‚äï \bobSh{\bobSec}) & ‚ê†‚ü™[Definition of XOR of shares]‚ü´
  A‚ÅÉ ‚ßº=‚ßΩ
      (\aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec}) ‚äï (\aliceSh{\bobSec} ‚äï \bobSh{\bobSec}) & ‚ê†‚ü™[Associativity of XOR]‚ü´
  A‚ÅÉ ‚ßº=‚ßΩ
      \aliceSec ‚äï \bobSec & ‚ê†‚ü™[Share Recovery]‚ü´
  A‚ÅÜ
M‚ÅÜ

Now for the tricky bit. How do we compute ‚∏®\aliceSec ‚àß \bobSec‚∏©? To describe this gate we assume that we have access to a
protocol called 1-4 Oblivious Transfer (OT). This protocol allows a sender, ‚∏®S‚∏©, to send 4 messages to a receiver, ‚∏®R‚∏©, in such a
way that (a) ‚∏®R‚∏© is only allowed to see 1 of the 4 messages and (b) ‚∏®S‚∏© cannot tell which message ‚∏®R‚∏© chose.

Assuming that we have access to such a protocol, we can compute \alice's share of the AND very simply:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \alices{œÉ}                          ‚ßº‚Üê‚ßΩ ùí∞(‚ù¥0,1‚ùµ)
  A‚ÅÉ \aliceSh{A‚∏® \aliceSec ‚àß \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \alices{œÉ}
  A‚ÅÜ
M‚ÅÜ

Now, we still need to figure out how \bob will compute his share of the AND. This will involve the 1-4 OT protocol in which \alice is the
sender and \bob is the receiver. Consider Table~\ref{tab:and-ot}, which is constructed by \alice. Each row indicates one of the possible
outcomes for \bob's shares, \bobSh{\aliceSec} and \bobSh{\bobSec}.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    \bobSh{\aliceSec} & \bobSh{\bobSec} & A‚∏® \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚àß \aliceSh{\bobSec} ‚äï \bobSh{\bobSec} A‚∏© & ‚∏®r‚∏© \\ \hline
    ‚∏®0‚∏© & ‚∏®0‚∏© & A‚∏® Œ±‚∏§0,0‚∏• = \aliceSh{\aliceSec} ‚äï 0 ‚àß \aliceSh{\bobSec} ‚äï 0 A‚∏© & A‚∏® r‚∏§0,0‚∏• = \alices{œÉ} ‚äï Œ±‚∏§0,0‚∏• A‚∏© \\ \hline
    ‚∏®0‚∏© & ‚∏®1‚∏© & A‚∏® Œ±‚∏§0,1‚∏• = \aliceSh{\aliceSec} ‚äï 0 ‚àß \aliceSh{\bobSec} ‚äï 1 A‚∏© & A‚∏® r‚∏§0,1‚∏• = \alices{œÉ} ‚äï Œ±‚∏§0,1‚∏• A‚∏© \\ \hline
    ‚∏®1‚∏© & ‚∏®0‚∏© & A‚∏® Œ±‚∏§1,0‚∏• = \aliceSh{\aliceSec} ‚äï 1 ‚àß \aliceSh{\bobSec} ‚äï 0 A‚∏© & A‚∏® r‚∏§1,0‚∏• = \alices{œÉ} ‚äï Œ±‚∏§1,0‚∏• A‚∏© \\ \hline
    ‚∏®1‚∏© & ‚∏®1‚∏© & A‚∏® Œ±‚∏§1,1‚∏• = \aliceSh{\aliceSec} ‚äï 1 ‚àß \aliceSh{\bobSec} ‚äï 1 A‚∏© & A‚∏® r‚∏§1,1‚∏• = \alices{œÉ} ‚äï Œ±‚∏§1,1‚∏• A‚∏© \\ \hline
  \end{tabular}
  \caption{\ins{TODO: couldn't figure out how to use colored math in here without an error.}}
  \label{tab:and-ot}
\end{table}

If \alice now sends ‚∏®(r‚∏§0,0‚∏•,‚ê£r‚∏§0,1‚∏•,‚ê£r‚∏§1,0‚∏•,‚ê£r‚∏§1,1‚∏•)‚∏© via 1-4 OT to \bob, then \bob can select the message which corresponds the outcome
of his shares. For example, if \bob's shares are ‚∏®\bobSh{\aliceSec} = \bobSh{\bobSec} = 0‚∏© then he would select ‚∏®r‚∏§0,0‚∏•‚∏© (corresponding
to the first row in Table~\ref{tab:and-ot}).

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \bobSh{\aliceSec ‚àß \bobSec} ‚ßº‚Üê‚ßΩ r‚ê£‚Äπwhere‚Ä∫‚ê£& r = r‚∏§0,0‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 0‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 0
  A‚ÅÉ & & & r = r‚∏§0,1‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 0‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 1
  A‚ÅÉ & & & r = r‚∏§1,0‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 1‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 0
  A‚ÅÉ & & & r = r‚∏§1,1‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 1‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 1
  A‚ÅÜ
M‚ÅÜ

Finally, let's check that this is correct and secure. First, correctness:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec ‚àß \bobSec} ‚äï \bobSh{\aliceSec ‚àß \bobSec} ‚ßº=‚ßΩ \alices{œÉ} ‚äï (\alices{œÉ} ‚äï Œ±‚∏§i,j‚∏•) & ‚ê†‚ü™[Definition of ‚∏®‚àß‚∏©]‚ü´
  A‚ÅÉ & & ‚Äπwhere‚Ä∫‚ê£i = \bobSh{\aliceSec}‚ê£‚Äπand‚Ä∫‚ê£j = \bobSh{\bobSec}
  A‚ÅÉ ‚ßº=‚ßΩ Œ±‚∏§i,j‚∏• & ‚ê†‚ü™[Fact~\ref{xor-inverse}]‚ü´
  A‚ÅÉ ‚ßº=‚ßΩ \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚àß \aliceSh{\bobSec} ‚äï \bobSh{\bobSec} & ‚ê†‚ü™[Definition (by OT on Table~\ref{tab:and-ot})]‚ü´
  A‚ÅÉ ‚ßº=‚ßΩ \aliceSec ‚àß \bobSec & ‚ê†‚ü™[Share Recovery]‚ü´
  A‚ÅÜ
M‚ÅÜ

Now, why is this secure? The security relies crucially on the properties of 1-4 OT. If \alice could tell which message \bob chose she would
immediately learn the values of \bob's shares and be able to recover \bob's secret. However, 1-4 OT guarantees that \alice cannot tell
which message \bob chose. Likewise, if \bob were able to see more than one of the messages sent by \alice then ‚∏®Œ± ‚äï \alices{œÉ}‚∏© would not
sufficiently protect ‚∏®Œ±‚∏©\footnote{More formally, the XOR with a random value forms a one-time pad (OTP) encryption scheme, which is only secure
  if the key is never reused.}. However, 1-4 OT guarantees that \bob can only see the message that he chooses.

In the next section, we'll look at how this protocol can be scaled up to a full-blown programming language for secure computation.

\subsection{A Taste of \mpc}

We now have a foundational understanding of how MPC works, but how can we write MPC programs? Symphony is a new
language proposed by Darais et al.~\cite{} which is an expressive, high-level language model for MPC. From here on, we instead refer to this
language instead as \mpc to more clearly constrast it with \obliv which is presented in Chapter~\ref{ch:oram}. As a means of gentle
introduction, let's consider the Millionaire's Problem in which two wealthy parties, \alice and \bob, would like to know who has a higher
net worth.

\begin{figure}[h]
M‚ÅÖ
\begin{array}{r@{‚ê†}lcl}
   ¬´0:¬ª & ùëöùëê3l{ ‚¶ëpar‚¶í[\alice,\bob] }
\\ ¬´1:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£x    ‚ßº=‚ßΩ ‚¶ëpar‚¶í[\alice]‚ê£‚¶ëread‚¶í‚ê£‚¶ëin‚¶í
\\ ¬´2:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£y    ‚ßº=‚ßΩ ‚¶ëpar‚¶í[\bob]‚ê£‚¶ëread‚¶í‚ê£‚¶ëin‚¶í
\\ ¬´3:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£¬´sx¬ª ‚ßº=‚ßΩ ‚¶ëshare‚¶í[\alice ‚Üí \alice,\bob]‚ê£x‚ê£‚¶ëin‚¶í
\\ ¬´4:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£¬´sy¬ª ‚ßº=‚ßΩ ‚¶ëshare‚¶í[\bob ‚Üí \alice,\bob]‚ê£y‚ê£‚¶ëin‚¶í
\\ ¬´5:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£r    ‚ßº=‚ßΩ ¬´sx¬ª < ¬´sy¬ª‚ê£‚¶ëin‚¶í
\\ ¬´6:¬ª & ‚ê†‚¶ëlet‚¶í‚ê£z    ‚ßº=‚ßΩ ‚¶ëreveal‚¶í[\alice,\bob]‚ê£r‚ê£‚¶ëin‚¶í
\\ ¬´7:¬ª & ‚ê†‚Ä¶
\end{array}
M‚ÅÜ
\caption{\mpc{} code for the Millionaire's Problem}
\label{fig:millionaires}
\end{figure}

The code in Figure~\ref{fig:millionaires} is written in the \mpc language. On line 0, the ‚∏®‚¶ëpar‚¶í[\alice,\bob]‚∏© block
means that \alice and \bob will execute everything in the block's lexical scope. Any other parties will ignore the
contents of the block and generate an \emph{opaque value} denoted \opaque. On line 1, \alice will ‚∏®‚¶ëread‚¶í‚∏© her own net worth,
‚∏®\alices{‚ãñnet-worth‚ãó}‚∏©, from her local machine and bind it to ‚∏®x‚∏©. \bob, however, will evaluate the expression ‚∏®‚¶ëpar‚¶í[\alice]‚ê£‚¶ëread‚¶í‚∏© to
\opaque because he is not included in the ‚∏®‚¶ëpar‚¶í[\alice]‚∏© block. On line 2, the same thing happens except \bob reads his net worth,
‚∏®\bobs{‚ãñnet-worth‚ãó}‚∏©, and binds it to ‚∏®y‚∏© while \alice binds \opaque to ‚∏®y‚∏© in her local environment. So, after line 2 the local
environments are as follows.

M‚ÅÖ
  AÀêcc
  A‚ÅÖ \alice & \bob
  A‚ÅÉ ‚ü®x ‚Ü¶ \alices{‚ãñnet-worth‚ãó},‚ê£y ‚Ü¶ \opaque‚ü©‚ê† & ‚ê†‚ü®x ‚Ü¶ \opaque,‚ê£y ‚Ü¶ \bobs{‚ãñnet-worth‚ãó}‚ü©
  A‚ÅÜ
M‚ÅÜ

On line 3, \alice splits her ‚∏®\alices{‚ãñnet-worth‚ãó}‚∏© into two shares. She keeps her share and sends \bob's share to him. We use the same
notation for shares which appears in Section~\ref{sec:mpc} to emphasize the connection between our GMW explanation and the execution model
of \mpc. On line 4, \bob splits his ‚∏®\bobs{‚ãñnet-worth‚ãó}‚∏© into two shares. He keeps his share and send's \alice's share to her. So, after
line 4 the local environments are as follows.

M‚ÅÖ
  AÀêllll
  A‚ÅÖ ùëöùëê2c{\alice} & ùëöùëê2c{\bob}
    A‚ÅÉ ‚ü®‚Ä¶,&‚ê£sx ‚Ü¶ \aliceSh{\alices{‚ãñnet-worth‚ãó}}, & ‚ê†‚ü®‚Ä¶,&‚ê£sx ‚Ü¶ \bobSh{\alices{‚ãñnet-worth‚ãó}}
    A‚ÅÉ    &‚ê£sy ‚Ü¶ \aliceSh{\bobs{‚ãñnet-worth‚ãó}}‚ü©   &     &‚ê£sy ‚Ü¶ \bobSh{\bobs{‚ãñnet-worth‚ãó}}‚ü©
  A‚ÅÜ
M‚ÅÜ

On line 5, \alice and \bob compute over their shares to produce a share indicating who is wealthier. Here we assume that the language knows
how to compute or encode ‚∏®<‚∏© over shares. For example, if the underlying MPC protocol were GMW then we would encode ‚∏®<‚∏© as a digital magnitude
circuit in terms of XOR and AND gates.

M‚ÅÖ
  AÀêcc
  A‚ÅÖ \alice & \bob
  A‚ÅÉ ‚ü®‚Ä¶,‚ê£r ‚Ü¶ \aliceSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©}‚ü© & ‚ê†‚ü®‚Ä¶,‚ê£r ‚Ü¶ \bobSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©}‚ü©
  A‚ÅÜ
M‚ÅÜ

Finally, on line 6, the shares of ‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}‚∏© among \alice and \bob are combined and the
cleartext result is revealed to both parties. Note that we could have revealed the result only to \alice, for example,
in which case \bob would send his share to \alice but not vice versa. Then, \alice could recover the cleartext result but \bob could not.
In this case, however, they both send their shares to each other. The XOR operator, ‚∏®‚äï‚∏©, is used to combine shares implicitly as part
of the ‚∏®‚¶ëreveal‚¶í‚∏©.

M‚ÅÖ
  AÀêllll
  A‚ÅÖ ùëöùëê2c{\alice} & ùëöùëê2c{\bob}
    A‚ÅÉ ‚ü®‚Ä¶,‚ê£z &{} ‚Ü¶ \aliceSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©} & ‚ê†‚ü®‚Ä¶,‚ê£z &{} ‚Ü¶ \aliceSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©}
    A‚ÅÉ       &{}‚ê£‚äï \bobSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©} & &{}‚ê£‚äï \bobSh{A‚∏®\alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}A‚∏©}
    A‚ÅÉ       &{}‚ê£= \alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}‚ü© & &{}‚ê£= \alices{‚ãñnet-worth‚ãó} < \bobs{‚ãñnet-worth‚ãó}‚ü©
  A‚ÅÜ
M‚ÅÜ

There are some interesting things to notice about this program (and \mpc) more generally. First, the programmer controls which parties
evaluate which expressions by using ‚∏®‚¶ëpar‚¶í‚∏© blocks. Second, cleartext ‚∏®‚¶ëread‚¶í‚∏© operations (lines 1,2) are mixed with ciphertext operations
(lines 3,4,5,6). Last, notice that the original program has a centralized interpretation. In a deployment, this program would run
independently on \alice and \bob who would communicate to jointly compute. Our explanation of the execution of Figure~\ref{fig:millionaires}
did not need to explicate any of that.

\ins{Considering also showing GCD here.}

\section{Oblivious RAM}

\subsection{Overview}

\subsection{A Taste of \obliv}

\chapter{A Language for Concise MPC}

\ins{Take from Symphony paper}

\chapter{A Language for Probabilistically Oblivious Computation}

\ins{Take from lam-obliv paper}

\chapter{Proposal: \lang{}, a secure MPC language with user-defined ORAM}

\chapter{Open Problems}

We briefly discuss some important open problems which affect the design of languages for
MPC and obliviousness. These are not addressed by \lang and I feel that they are promising
areas for future research.

\section{Resource Awareness}

MPC programs are expensive. Something something orders of magnitude slower~\cite{}. This due principally to the communication
required. For example in GMW, an AND gate requires a round of communication and the 1-4 OT requires an encryption scheme.
Programmers who are not experts in MPC will require information about the cost of the programs they are writing. This could be
handled elegantly by the language. There is ample research in type-based resource analysis~\cite{}, for example. \ins{TODO: this is rough}

\section{Oblivious Data Structures}

Our prior work has shown that Oblivious Data Structures (ODS's), proposed by Wang et al., do not satisfy PMTO.\ins{replace with ref. to theorem} Even though ODS's are safe due to negligibl overflow probability, we are unable to verify that fact in \lang. We would like to find some
way to support ODS's within the language while retaining the security guarantees provided by the tyep system.

\section{Other Security Policies}

PMTO\% is perhaps the most obvious security policone could prove about MPC programs which admit ORAM. However, it is not the only property
one could prove. There is a rich literature of different declassification policies, as well as weaker variants of (P)MTO like Differential
MTO~\cite{} and manual computational proofs of securit with explicit complexity-theoretic reductions~\cite{easycrypt}.

\end{document}
