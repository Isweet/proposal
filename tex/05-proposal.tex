\chapter{Proposal: \lang, A Secure MPC Language With User-Defined ORAM}
\label{ch:proposal}

Up to this point, we have seen two languages (\mpc and \obliv) which, individually, have all the language
features that we are interested in. \obliv is \textbf{Probabilistic} and \textbf{High Assurance} while \mpc
is designed for MPC and \textbf{Abstractly Sequential}. The purpose of \lang is to unify these two languages
into a single MPC language satisfying all three properties. In this chapter, we formally propose \lang and
provide sketch of how it could be designed and implemented. Along the way, we point out potential difficulties
and hypothesize about how to overcome them.

\section{Design}
\label{sec:proposal-design}

The formal language design for \lang consists of the syntax (\Cref{fig:lang-syntax}), type system (\Cref{fig:lang-types}),
a probabilistic sequential semantics (\Cref{fig:lang-seq}), and a probabilistic distributed semantics (\Cref{fig:lang-dist}).
The type system should be sound, and additionally it should enforce~\nameref{thm:lang-pmto}. We claim that~\nameref{thm:lang-pmto}
is the appropriate extension of \obliv's~\nameref{thm:obliv-pmto} to the MPC setting. The ``\%" should be read as ``modulo'' and refers
to the PMTO proerty being generalized to handle declassifications. The last theorem we expect \lang to satisfy is~\nameref{thm:lang-simulation}
which is the appropriate extension of \mpc's~\nameref{thm:mpc-simulation} to the probabilistic setting.

\FigureLangSyntax{fig:lang-syntax}{\lang formal syntax.}

\subsection{Syntax}
\label{subsec:proposal-design-syntax}

The proposed syntax of \lang is in~\Cref{fig:lang-syntax}. The syntax of \lang builds primarily
on that of \mpc (\Cref{fig:mpc-syntax}), with the addition of some features from \obliv (\Cref{fig:obliv-syntax}).
The syntax is not presented in ANF (as \mpc was) for clarity. In the future, we will likely transition
to ANF to simplify the metatheory.

Most of \lang's expressions are standard and work identically to \mpc and \obliv.
We have variables ⸨x⸩; integers ⸨i⸩; booleans ⸨b⸩; party sets ⸨p⸩;
binary operations ⸨e ⊙ e⸩;
conditionals ⸨⦑if⦒␣e␣⦑then⦒␣e␣⦑else⦒␣e⸩; multiplexors ⸨e ¿ e ◇ e⸩;
sum creation ⸨ιᵢ␣e⸩ and elimination ⸨⦑case⦒␣x␣❴y⍪e⸤1⸥❵␣❴y⍪e⸤2⸥❵⸩;
pair creation ⸨⟨e,e⟩⸩ and elimination ⸨πᵢ␣e⸩;
reference creation ⸨⦑ref⦒␣e⸩, dereference ⸨¡x⸩, and assignment ⸨x ≔ y⸩;
function creation ⸨λ⸤z⸥x⍪ e⸩ and application ⸨x␣y⸩;
local variable binding ⸨⦑let⦒␣x=e⸤1⸥␣⦑in⦒␣e⸤2⸥⸩;
par(allel) execution ⸨⦑par⦒[e]␣e⸩;
local read ⸨⦑read⦒␣μ⸩ and write ⸨⦑write⦒␣e⸩;
MPC share ⸨⦑share⦒[e→e]␣e⸩ and reveal ⸨⦑reveal⦒⸤b⸥[e]␣e⸩;
uniform distributions ⸨⦑unif⦒⸢ρ⸣␣μ⸩;
and observation of distributions ⸨⦑observe⦒␣e⸩.

Literals no longer have a label ⸨l⸩ attached to them. Instead, we use
the combination of the location annotation ⸨@m⸩ and protocol annotation
⸨ψ⸩ as the information flow label.
The multiplexor, ⸨e₁ ¿ e₂ ◇ e₃⸩, works as in \mpc evaluating to either
⸨v₂⸩ or ⸨v₃⸩. The \obliv multiplexor can be encoded as
⸨e₁ ¿ e₂ ◇ e₃ ⩴ e₁ ¿ ⟨e₂,e₃⟩ ◇ ⟨e₃,e₂⟩⸩. Pairs are eliminated using
projection ⸨πᵢ⸩ as in \mpc rather than with pattern matching ⸨⦑let⦒␣x,y = e␣⦑in⦒␣e⸩
as in \obliv. The local read operation ⸨⦑read⦒␣μ⸩ takes a base type ⸨μ⸩ which is
type we expect to read. The reveal expression ⸨⦑reveal⦒⸤b⸥[e]␣e⸩ takes a boolean
⸨b⸩ indicating if the revelation is expected to be benign (zero-leakage). When
⸨b = ⦑true⦒⸩, we can think of this as acting like ⸨⦑cast⦒⸤‹P›⸥⸩ in \obliv. We rename
the ⸨⦑flip⦒⸢ρ⸣()⸩ expression from \obliv to ⸨⦑unif⦒⸢ρ⸣␣μ⸩ because we may generate
uniform booleans or integers. Finally, the ⸨⦑observe⦒␣e⸩ expression acts like ⸨⦑cast⦒⸤‹S›⸥⸩
from \obliv taking a uniform value and ``observing'' the underlying sample.

Types ⸨τ⸩ have location annotations, just like the values in the sequential semantics of \mpc (\Cref{fig:mpc-seq-aux}).
The located types ⸨σ⸩ refer recursively to types ⸨τ⸩. ⸨⦑prins⦒⸩ is the type of principal sets. The mode annotation ⸨m⸩ on function types ⸨τ ᵐ→ τ⸩ is the static
analog of the mode captured by closures in \mpc. Finally, our base types ⸨μ⸩ are augmented with three annotations. The probability
annotation, ⸨φ⸩, indicates whether this type is uniform or not. ⸨⦑\faThumbsUp⦒⸩ indicates a uniform type (⸨⦑flip⦒⸩ in
\obliv) and ⸨⦑\faThumbsDown⦒⸩ indicates a non-uniform type (⸨⦑bit⦒⸩ in \obliv). The probability region annotation, ⸨ρ⸩,
serves the same purpose as the annotation on the ⸨⦑flip⦒⸩ and ⸨⦑bit⦒⸩ types in \obliv. The protocol annotation, ⸨ψ⸩,
serves the same purpose as the protocol annotation in \mpc. So, for example, the ⸨⦑flip⦒⸢ρ⸣⸩ type from \obliv can be
represented as ⸨⦑bool⦒⸢⦑\faThumbsUp⦒ ; ρ ; ⋅⸣⸩ in \lang. This also allows us to represent, for example, the type
of encrypted uniform distributions of type ⸨μ⸩ among parties ⸨m⸩: ⸨μ⸢⦑\faThumbsUp⦒ ; ρ ; ⦑enc⦒⋕m⸣⸩. We can
also encode types representable in \mpc. For example, ⸨⦑int⦒⸢⦑\faThumbsDown⦒ ; ⊥ ; ⦑enc⦒⋕m⸣⸩, the type of non-random
(⸨⊥⸩) integers encrypted among parties ⸨m⸩.

\subsection{Sequential Semantics}
\label{subsec:proposal-design-seq}

We expect the sequential semantics of \lang to be a standard combination of the sequential
semantics of \mpc (\Cref{fig:mpc-seq}) and \obliv (\Cref{fig:obliv-sem}). In particular, we
expect to be able to take the sequential semantics of \mpc suitably extended and lift them
to the probabilistic setting by defining a monadic semantics in the style of \obliv in which
each \mpc rule corresponds to a \lang rule that produces a point distribution (⸨‹return›⸩ in
the Giry monad). For example, here's two candidate rules for introducing pairs and performing
a zero-information revelation.

P⁅ Rː⦗Allyn-Pair⦘
   R⁅{Aːrcl
      A⁅ v₁ ⧼=⧽ γ(x₁)↙⸤m⸥
      A⁃ v₂ ⧼=⧽ γ(x₂)↙⸤m⸥
      A⁆}
      -------------------------------------------
      γ ⊢⸤m⸥ δ,⟨x₁,x₂⟩ ↪ ‹return›(δ,⟨v₁,v₂⟩@m)
      R⁆
P⁃ Rː⦗Allyn-Reveal-True⦘
   R⁅{Aː[b]rcl
      A⁅ p@m          ⧼=⧽ γ(x₁)↙⸤m⸥
      A⁃ q@m          ⧼=⧽ γ(x₂)↙⸤m⸥
      A⁃ i⸢⦑\faThumbsUp⦒ ; ⦑enc⦒⋕p⸣@p ⧼=⧽ γ(x₃)↙⸤p⸥
      A⁆}
   R⁃{Aː[b]rcl
      A⁅ q ⧼≠⧽ ∅
      A⁃ m ⧼=⧽ p ∪ q
      A⁆}
      -------------------------------------------
      γ ⊢⸤m⸥ δ,⦑reveal⦒⸤⦑true⦒⸥[x₁→x₂]␣x₃ ↪ ‹return›(δ,i⸢⦑\faThumbsDown⦒⸣@q)
   R⁆
P⁆

We expect most rules to follow this adaptation pattern. However, one design decision
that must be made is whether or not to constrain the mode when evaluating a uniform
expression, ⸨⦑unif⦒⸢ρ⸣␣μ⸩. The simplest design is to force the mode to be a singleton.
If we want multiple parties to agree on a uniform value, it must be explicitly sent (shared)
with those parties. Alternatively, we could allow ⸨⦑unif⦒⸢ρ⸣␣μ⸩ to be evaluated in an arbitrary
mode ⸨m⸩. However, this is more challenging to realize in a distributed implementation since the
entropy on all parties has to be identical throughout execution to ensure that the uniform values
they generate are also identical. The advantage of this approach is that it is (potentially) faster
since there is no communication needed among the parties.

As we will see, most of the complexity of \lang crops up in the design of the type system, and the
proof techniques required to prove~\nameref{thm:lang-pmto} and~\nameref{thm:lang-simulation}.

\subsection{Type System}
\label{subsec:propsal-design-types}

\ins{TODO}
% Doesn't address types for first-class principals a la Wysteria
% What should labels be?
% Type Soundness
% PMTO%

\subsection{Distributed Semantics}
\label{subsec:proposal-design-dist}

\ins{TODO}

% Simulation

\section{Implementation}
\label{sec:proposal-impl}

\ins{TODO: revise ... super stale}

We must now consider if the formal language we have designed is useful. Can we write interesting programs in the language?
Will those programs be efficient? Questions such as these must be answered empirically. We will address both of these questions
using the ORAM protocols described in~\cref{ch:oram}. In particular, since we are claiming that our type system has a very powerful
property ---~\cref{thm:lang-pmto} --- we might also expect it to be very restrictive. How do we know it actually accepts the ORAM
protocols we would like to prove are oblivious? For this reason, we take ORAM protcols to be representative ``interesting programs.''

The \mpc language has an existing Haskell interpreter. However, this interpreter only implements the centralized semantics of \mpc.
In particular, it doesn't actually perform any MPC and doesn't run as multiple communicating processes. Our first implementation
goal will be to extend the existing interpreter to also support a distribued mode. We have already partially completed this task
by implementing a Haskell FFI to the C++ bindings for EMP. The prototype distributed mode is capable of sharing integers, performing
primitive operations (e.g. addition, comparison), and revealing the result. For example, we have successfully implemented the Millionaire's Problem
from~\ref{sec:background-symphony}. There is more work to support ORAM -- we will need to handle random numbers, references, and
more primitive operations at a minimum. Furthermore, since EMP is limited to two parties, so too is our distributed mode.

The existing \mpc implementation does not have a type checker. We will first add the type checker of \mpc to the implementation without
the additional features (affinity, probability regions) required for \lang. This type system should be sufficient for checking, for example,
that Trivial ORAM\footnote{Interestingly, this will already confirm that Trivial ORAM in the MPC model is~\ref{thm:mpc-mto}.}. Then, we will
add the challenging features of affinity and probability regions. In prior work, we implemented the type system of \obliv and used it to
type check various ORAM case studies. We expect that we will be able to use our experience from that artifact here.

Finally, we can address the two empirical questions mentioned above. First, we will implement the ORAM protocols in our language and confirm
that they type check (and are therefore oblivious). Second, with our distributed mode, we will confirm that the ORAM protocols have the
expected asymptotic behavior. We will perform a series of experiments in which \ins{todo: similar to experiments in FLORAM paper}
This will confirm that our language can support RAM-model computation which is competitive with existing languages that offer ORAM support
(e.g. Obliv-C, SCALE-MAMBA).

\ins{mention somewhere that these ORAM implementations are different from the ones in \obliv -- these are not client-server but instead in
  the ORAM-SC model in which neither party knows the position tag of inserted elements.}
