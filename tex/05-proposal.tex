\chapter{Proposal: \lang, A Secure MPC Language With User-Defined ORAM}
\label{ch:proposal}

Up to this point, we have seen two languages (\mpc and \obliv) which, individually, have all the language
features that we are interested in. \obliv is \textbf{Probabilistic} and \textbf{High Assurance} while \mpc
is designed for MPC and \textbf{Abstractly Sequential}. The purpose of \lang is to unify these two languages
into a single MPC language satisfying all three properties. In this chapter, we formally propose \lang and
provide sketch of how it could be designed and implemented. Along the way, we point out potential difficulties
and hypothesize about how to overcome them.

\section{Design}
\label{sec:proposal-design}

The formal language design for \lang consists of the syntax (\Cref{fig:lang-syntax}), type system (\Cref{fig:lang-types}),
a probabilistic sequential semantics (\Cref{fig:lang-seq}), and a probabilistic distributed semantics (\Cref{fig:lang-dist}).
The type system should be sound, and additionally it should enforce~\nameref{thm:lang-pmto}. We claim that~\nameref{thm:lang-pmto}
is the appropriate extension of \obliv's~\nameref{thm:obliv-pmto} to the MPC setting. The ``\%" should be read as ``modulo'' and refers
to the PMTO proerty being generalized to handle declassifications. The last theorem we expect \lang to satisfy is~\nameref{thm:lang-simulation}
which is the appropriate extension of \mpc's~\nameref{thm:mpc-simulation} to the probabilistic setting.

\FigureLangSyntax{fig:lang-syntax}{\lang formal syntax.}

\subsection{Syntax}
\label{subsec:proposal-design-syntax}

The proposed syntax of \lang is in~\Cref{fig:lang-syntax}. The syntax of \lang builds primarily
on that of \mpc (\Cref{fig:mpc-syntax}), with the addition of some features from \obliv (\Cref{fig:obliv-syntax}).
The syntax is not presented in ANF (as \mpc was) for clarity. In the future, we will likely transition
to ANF to simplify the metatheory.

Most of \lang's expressions are standard and work identically to \mpc and \obliv.
We have variables ⸨x⸩; integers ⸨i⸩; booleans ⸨b⸩; party sets ⸨p⸩;
binary operations ⸨e ⊙ e⸩;
conditionals ⸨⦑if⦒␣e␣⦑then⦒␣e␣⦑else⦒␣e⸩; multiplexors ⸨e ¿ e ◇ e⸩;
sum creation ⸨ιᵢ␣e⸩ and elimination ⸨⦑case⦒␣x␣❴y⍪e⸤1⸥❵␣❴y⍪e⸤2⸥❵⸩;
pair creation ⸨⟨e,e⟩⸩ and elimination ⸨πᵢ␣e⸩;
reference creation ⸨⦑ref⦒␣e⸩, dereference ⸨¡x⸩, and assignment ⸨x ≔ y⸩;
function creation ⸨λ⸤z⸥x⍪ e⸩ and application ⸨x␣y⸩;
local variable binding ⸨⦑let⦒␣x=e⸤1⸥␣⦑in⦒␣e⸤2⸥⸩;
par(allel) execution ⸨⦑par⦒[e]␣e⸩;
local read ⸨⦑read⦒␣μ⸩ and write ⸨⦑write⦒␣e⸩;
MPC share ⸨⦑share⦒[e→e]␣e⸩ and reveal ⸨⦑reveal⦒⸤b⸥[e]␣e⸩;
uniform distributions ⸨⦑unif⦒⸢ρ⸣␣μ⸩;
and observation of distributions ⸨⦑observe⦒␣e⸩.

Literals no longer have a label ⸨l⸩ attached to them. Instead, we use
the combination of the location annotation ⸨@m⸩ and protocol annotation
⸨ψ⸩ as the information flow label.
The multiplexor, ⸨e₁ ¿ e₂ ◇ e₃⸩, works as in \mpc evaluating to either
⸨v₂⸩ or ⸨v₃⸩. The \obliv multiplexor can be encoded as
⸨e₁ ¿ e₂ ◇ e₃ ⩴ e₁ ¿ ⟨e₂,e₃⟩ ◇ ⟨e₃,e₂⟩⸩. Pairs are eliminated using
projection ⸨πᵢ⸩ as in \mpc rather than with pattern matching ⸨⦑let⦒␣x,y = e␣⦑in⦒␣e⸩
as in \obliv. The local read operation ⸨⦑read⦒␣μ⸩ takes a base type ⸨μ⸩ which is
type we expect to read. The reveal expression ⸨⦑reveal⦒⸤b⸥[e]␣e⸩ takes a boolean
⸨b⸩ indicating if the revelation is expected to be benign (zero-leakage). When
⸨b = ⦑true⦒⸩, we can think of this as acting like ⸨⦑cast⦒⸤‹P›⸥⸩ in \obliv. We rename
the ⸨⦑flip⦒⸢ρ⸣()⸩ expression from \obliv to ⸨⦑unif⦒⸢ρ⸣␣μ⸩ because we may generate
uniform booleans or integers. Finally, the ⸨⦑observe⦒␣e⸩ expression acts like ⸨⦑cast⦒⸤‹S›⸥⸩
from \obliv taking a uniform value and ``observing'' the underlying sample.

Types ⸨τ⸩ have location annotations, just like the values in the sequential semantics of \mpc (\Cref{fig:mpc-seq-aux}).
The located types ⸨σ⸩ refer recursively to types ⸨τ⸩. ⸨⦑prins⦒⸩ is the type of principal sets. The mode annotation ⸨m⸩ on function types ⸨τ ᵐ→ τ⸩ is the static
analog of the mode captured by closures in \mpc. Finally, our base types ⸨μ⸩ are augmented with three annotations. The probability
annotation, ⸨φ⸩, indicates whether this type is uniform or not. ⸨⦑\faThumbsUp⦒⸩ indicates a uniform type (⸨⦑flip⦒⸩ in
\obliv) and ⸨⦑\faThumbsDown⦒⸩ indicates a non-uniform type (⸨⦑bit⦒⸩ in \obliv). The probability region annotation, ⸨ρ⸩,
serves the same purpose as the annotation on the ⸨⦑flip⦒⸩ and ⸨⦑bit⦒⸩ types in \obliv. The protocol annotation, ⸨ψ⸩,
serves the same purpose as the protocol annotation in \mpc. So, for example, the ⸨⦑flip⦒⸢ρ⸣⸩ type from \obliv can be
represented as ⸨⦑bool⦒⸢⦑\faThumbsUp⦒ ; ρ ; ⋅⸣⸩ in \lang. This also allows us to represent, for example, the type
of encrypted uniform distributions of type ⸨μ⸩ among parties ⸨m⸩: ⸨μ⸢⦑\faThumbsUp⦒ ; ρ ; ⦑enc⦒⋕m⸣⸩. We can
also encode types representable in \mpc. For example, ⸨⦑int⦒⸢⦑\faThumbsDown⦒ ; ⊥ ; ⦑enc⦒⋕m⸣⸩, the type of non-random
(⸨⊥⸩) integers encrypted among parties ⸨m⸩.

\subsection{Sequential Semantics}
\label{subsec:proposal-design-seq}

We expect the sequential semantics of \lang to be a standard combination of the sequential
semantics of \mpc (\Cref{fig:mpc-seq}) and \obliv (\Cref{fig:obliv-sem}). In particular, we
expect to be able to take the sequential semantics of \mpc suitably extended and lift them
to the probabilistic setting by defining a monadic semantics in the style of \obliv in which
each \mpc rule corresponds to a \lang rule that produces a point distribution (⸨‹return›⸩ in
the Giry monad). For example, here's two candidate rules for introducing pairs and performing
a zero-information revelation.

P⁅ Rː⦗Allyn-Pair⦘
   R⁅{Aːrcl
      A⁅ v₁ ⧼=⧽ γ(x₁)↙⸤m⸥
      A⁃ v₂ ⧼=⧽ γ(x₂)↙⸤m⸥
      A⁆}
      -------------------------------------------
      γ ⊢⸤m⸥ δ,⟨x₁,x₂⟩ ↪ ‹return›(δ,⟨v₁,v₂⟩@m)
      R⁆
P⁃ Rː⦗Allyn-Reveal-True⦘
   R⁅{Aː[b]rcl
      A⁅ p@m          ⧼=⧽ γ(x₁)↙⸤m⸥
      A⁃ q@m          ⧼=⧽ γ(x₂)↙⸤m⸥
      A⁃ i⸢⦑\faThumbsUp⦒ ; ⦑enc⦒⋕p⸣@p ⧼=⧽ γ(x₃)↙⸤p⸥
      A⁆}
   R⁃{Aː[b]rcl
      A⁅ q ⧼≠⧽ ∅
      A⁃ m ⧼=⧽ p ∪ q
      A⁆}
      -------------------------------------------
      γ ⊢⸤m⸥ δ,⦑reveal⦒⸤⦑true⦒⸥[x₁→x₂]␣x₃ ↪ ‹return›(δ,i⸢⦑\faThumbsDown⦒⸣@q)
   R⁆
P⁆

We expect most rules to follow this adaptation pattern. However, one design decision
that must be made is whether or not to constrain the mode when evaluating a uniform
expression, ⸨⦑unif⦒⸢ρ⸣␣μ⸩. The simplest design is to force the mode to be a singleton.
If we want multiple parties to agree on a uniform value, it must be explicitly sent (shared)
with those parties. Alternatively, we could allow ⸨⦑unif⦒⸢ρ⸣␣μ⸩ to be evaluated in an arbitrary
mode ⸨m⸩. However, this is more challenging to realize in a distributed implementation since the
entropy on all parties has to be identical throughout execution to ensure that the uniform values
they generate are also identical. The advantage of this approach is that it is (potentially) faster
since there is no communication needed among the parties.

As we will see, most of the complexity of \lang crops up in the design of the type system, and the
proof techniques required to prove~\nameref{thm:lang-pmto} and~\nameref{thm:lang-simulation}.

\subsection{Type System}
\label{subsec:propsal-design-types}

\ins{TODO}
% Doesn't address types for first-class principals a la Wysteria
% What should labels be?
% Type Soundness
% PMTO%

\subsection{Distributed Semantics}
\label{subsec:proposal-design-dist}

\ins{TODO}

% Simulation

\section{Implementation}
\label{sec:proposal-impl}

Our implementation of \lang will build on the existing Haskell interpreter for \mpc, \system, described in~\Cref{sec:mpc-impl}.
The interpreter will need to be extended with support for a cryptographically secure PRNG. This will serve as a secure foundations for
generating uniform, random distributions which are suitable for use in cryptographic protocols. One possibility is to link the interpreter
against OpenSSL and use AES in CTR mode.

Perhaps the biggest implementation effort will be adding a sufficiently expressive type checker to the interpreter. As discussed
in~\Cref{subsec:proposal-design-types}, the type system will require polymorphism over probability regions and party sets. To
type check interesting programs, we will also need to support constraints over regions and party sets, likely in the form of
refinement types. To implement such a type system will require linking against an SMT solver like Z3~\cite{} to check that
constraints are satisfiable. All that being said, we have implemented a type checker for \obliv as part of the \textsc{OblivML}
interpreter so we anticipate that consulting this code will make the implementation effort much easier.

As discussed in~\Cref{sec:mpc-impl}, the \system interpreter already has an extensive standard library, test suite, and benchmark
suite. We will evaluate how much of this existing \system code can be made to typecheck (i.e. by adding type annotations where necessary).
However, none of this existing code uses randomness. So, we anticipate that this will primarily evaluate the expressiveness of our
typing rule for party set polymorphism and associated constraints. To evaluate the expressiveness of code which uses randomness,
we'll implement a new set of benchmark programs. Our hope is to implement and type check One-Time Pad, Circuit ORAM,
Binary Search (on top of Circuit ORAM), and an optimized QuickSort using permutation~\cite{hamada}. All four of these programs
will rely on the type system to ensure that certain revelations leak zero information. The inclusion of One-Time
Pad and optimized QuickSort will provide evidence that our type system generalizes to programs beyond ORAM.

We will evaluate the efficiency of \lang using a methodology identical to the one described in \Cref{sec:mpc-impl} on the
benchmark programs described above (OTP, Circuit ORAM, Binary Search, and optimized QuickSort). We will also repeat the MPC
benchmarks to see how much performance improvement we achieve through static typing. We expect at least a modest improvement,
since we can omit all runtime checks for well-typed programs.
