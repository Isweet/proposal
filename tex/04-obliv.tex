\chapter{\obliv, A Language for Probabilistically Oblivious Computation}
\label{ch:obliv}

\mwh{Same point here as the last chapter: What's the high-level
  takeaway for a committee member that just wants to see the dots and
  assess the big picture, rather than see the detailed connections
  between the dots?}

An oblivious computation is one that is free of direct and indirect information leaks, e.g., due to observable differences
in timing and memory access patterns. In this chapter, we'll give a formal description of \obliv, a core language whose
type system enforces obliviousness. We show that \obliv satisfies~\nameref{thm:obliv-pmto}, a probabilistic variant of obliviousness.
We also show that \obliv's type system is expressive enough to typecheck an asymptotically optimal client-server ORAM implementation.

\section{Design}
\label{sec:obliv-design}

The formal language design consists of the syntax (\Cref{fig:obliv-syntax}), type system (\Cref{fig:obliv-types},
and a small-step, probabilistic operational semantics (\Cref{fig:obliv-sem}. The type system is sound, and designed to additionally
enforce that well-typed programs satisfy~\nameref{thm:obliv-pmto}. In other words, they are (probabilistically) oblivious.
The proof of~\nameref{thm:obliv-pmto} is complex and we elide the full details here. Interested readers can consult the full paper~\cite{}.

\FigureOblivSyntax{fig:obliv-syntax}{\obliv formal syntax.}

\subsection{Syntax}
\label{subsec:obliv-design-syntax}

Figure~\ref{fig:obliv-syntax} shows the syntax for \obliv. The term language is
expressions ‚∏®e‚∏©. The set of values ‚∏®v‚∏© is comprised of (1) base values such as
variables ‚∏®x‚∏© (included to enable a substitution-based semantics) and recursive function
definitions ‚∏®‚¶ëfun‚¶í‚∏§y‚∏•(x{‚¶Ç}œÑ).e‚∏© where the function body may refer to itself
using variable ‚∏®y‚∏©; and (2) connectives from the expression language ‚∏®e‚∏© which
identify a subset of expressions which are also values, such as pairs ‚∏®‚ü®v,v‚ü©‚∏©
with type ‚∏®œÑ √ó œÑ‚∏©.

Expressions also include bit literals ‚∏®b‚∏§‚Ñì‚∏•‚∏© (of type ‚∏®‚¶ëbit‚¶í‚∏§‚Ñì‚∏•‚∏¢‚ä•‚∏£‚∏©) which are
either ‚∏®‚¶ëO‚¶í‚∏© or ‚∏®‚¶ëI‚¶í‚∏© and annotated with their security label
‚∏®‚Ñì‚∏©.
%
A security label ‚∏®‚Ñì‚∏© is either
‚∏®‚ÄπS‚Ä∫‚∏© (secret) or ‚∏®‚ÄπP‚Ä∫‚∏© (public). Values with the label ‚∏®‚ÄπS‚Ä∫‚∏© are invisible to
the adversary. Bit types include this security label along with a probability
region ‚∏®œÅ‚∏©. The expression ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£()‚∏© produces a flip value, i.e.,
a uniformly random bit of type ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£‚∏©.
The annotation assigns the coin to region ‚∏®œÅ‚∏©. Coin flips are semantically secret, and have
limited use; we can compute on one using ‚∏®‚¶ëmux‚¶í‚∏© or ‚∏®‚¶ëxor‚¶í‚∏©, cast one to a
public bit via ‚∏®‚¶ëcast‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏©, or cast to a secret bit via ‚∏®‚¶ëcast‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏©. To
simplify the type system, casts only apply to values, however ‚∏®‚¶ëcast‚¶í‚∏§‚Ñì‚∏•(e)‚∏©
could be used as shorthand for ‚∏®‚¶ëlet‚¶í‚ê£x = e‚ê£‚¶ëin‚¶í‚ê£‚¶ëcast‚¶í‚∏§‚Ñì‚∏•(x)‚∏©.

The expression ‚∏®e‚ÇÅ {¬ø} e‚ÇÇ {‚óá} e‚ÇÉ‚∏© unconditionally evaluates ‚∏®e‚ÇÇ‚∏© and ‚∏®e‚ÇÉ‚∏© and
returns their values as a pair in the given order if ‚∏®e‚ÇÅ‚∏© evaluates to ‚∏®‚¶ëI‚¶í‚∏©, or in the
opposite order if it evaluates to ‚∏®‚¶ëO‚¶í‚∏©. This is very similar to the multiplexor
from \mpc, except that it returns a pair. The components of tuples
‚∏®e‚∏© constructed as ‚∏®‚ü®e‚ÇÅ,e‚ÇÇ‚ü©‚∏© can be accessed via ‚∏®‚¶ëlet‚¶í‚ê£x‚ÇÅ,x‚ÇÇ=e‚ê£‚¶ëin‚¶í‚ê£...‚∏©
\obliv also has normal let binding, function application, and means to manipulate
mutable reference cells.

\obliv captures the key elements that make implementing oblivious
algorithms possible, notably: random and secret bits, trace-oblivious
multiplexing, public revelation of secret random values, and general
computational support in tuples, conditionals and recursive functions.
Other features can be encoded in these, e.g., general numbers and
operators on them can be encoded as tuples of bits, and arrays can be
encoded as tuples of references (read/written using (nested) conditionals).
Our prototype interpreter implements these things directly.

\FigureOblivSemantics{fig:obliv-sem}{\obliv semantics.}

\subsection{Semantics}
\label{subsec:obliv-design-sem}

\Cref{fig:obliv-sem} presents a monadic, probabilistic small-step
semantics for \obliv programs. The top of the figure contains some new and
extended syntax. Values (and, by extension, expressions) are extended with
forms for bit values ‚∏®‚¶ëbitv‚¶í‚∏§‚Ñì‚∏•(b)‚∏©, flip values ‚∏®‚¶ëflipv‚¶í(b)‚∏©, and
reference locations ‚∏®‚¶ëlocv‚¶í(Œπ)‚∏©; these do not appear in source programs. Stores
‚∏®œÉ‚∏© map locations to values. Stores are paired with expressions to form
\emph{configurations} ‚∏®œÇ‚∏©. A sequence of configurations arising during an
evaluation is collected in a \emph{trace} ‚∏®t‚∏©.  We define evaluation
contexts ‚∏®E‚∏© (not shown) in the style of~\citet{felleisen1992revised} to enforce a
left-to-right, call-by-value evaluation strategy.

The semantics is defined using the standard ‚Äúdenotational‚Äù discrete probability monad
‚∏®ùíü‚∏©~\cite{10.1007/BFb0092872,Ramsey:2002:SLC:503272.503288}.

In the probability monad ‚∏®ùíü‚∏©, the ‚∏®‚Äπreturn‚Ä∫‚∏© operation constructs a point
distribution, and the ‚∏®‚Äπbind‚Ä∫‚∏© operation encodes the law of total probability,
{i.e.}, constructs a marginal distribution from a conditional one. We only use
proper distributions in the sense that the combined mass of all elements sums
to 1. We do not denote possibly non-terminating programs directly into the
monad, and therefore do not require the use of computable
distributions~\cite{huang-computable-distributions} or
sub-probability distributions~\cite{monniaux-ai-prob}‚Äîwe use the monad only to denote distributions of
configurations which occur after a finite number of small-step transitions,
which is total.

The definition of ‚∏®‚Äπstep‚Ä∫‚∏© describes how a single configuration advances in a
single probabilistic step, yielding a distribution of resulting configurations.
The definition uses Haskell-style ‚∏®‚Äπdo‚Ä∫‚∏© notation as the usual notation for
‚∏®‚Äπbind‚Ä∫‚∏©. Starting from the bottom, we can see that a value ‚∏®v‚∏© advances to
itself (more on why, below) and evaluating a redex ‚∏®e‚∏© within a context ‚∏®E‚∏©
steps the former and packages its result back with the latter, as usual. The
cases for let binding, pair deconstruction, and function application are
standard, using a substitution-based semantics. Likewise, rules for creating,
reading, and writing from references operate on the store ‚∏®œÉ‚∏© as
usual.

Moving to the first case, we see that literals ‚∏®b‚∏§‚Ñì‚∏•‚∏© evaluate in one
step to bit values. A ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£()‚∏© expression evaluates to either
‚∏®‚¶ëflipv‚¶í(‚¶ëI‚¶í)‚∏© or ‚∏®‚¶ëflipv‚¶í(‚¶ëO‚¶í)‚∏© as determined by ‚∏®‚Äπbit‚Ä∫‚∏©, which ‚∏®¬Ω‚∏©
probability for each outcome.
%
The ‚∏®‚¶ëcast‚¶í‚∏§‚Ñì‚∏•‚∏© case converts a flip to a similarly-labeled bit value.
%
The next few cases use the three-argument metafunction ‚∏®‚Äπcond‚Ä∫(b,X,Y)‚∏©, which
returns ‚∏®X‚∏© if ‚∏®b‚∏© is ‚∏®‚¶ëI‚¶í‚∏©, and ‚∏®Y‚∏© otherwise.
%
The two ‚∏®‚¶ëbitv‚¶í‚∏§ùìÅ‚∏•(b) ¬ø v‚ÇÇ ‚óá v‚ÇÉ‚∏© cases operate in a similar way: they return the
second two arguments of the multiplexor in order when the first
argument is ‚∏®‚¶ëbitv‚¶í‚∏§‚Ñì‚∏•(‚¶ëI‚¶í)‚∏©, and in reverse order when it is
‚∏®‚¶ëbitv‚¶í‚∏§‚Ñì‚∏•(‚¶ëO‚¶í)‚∏©. The security label of the result is the join of the labels of
all elements in involved. (This is not needed for flip values, since these are
always fixed to be secret.)
%
The case for ‚∏®‚¶ëif‚¶í‚∏© also uses ‚∏®‚Äπcond‚Ä∫‚∏© in the expected manner. The
case for ‚∏®‚¶ëxor‚¶í‚∏© permits xor-ing a bit with a flip, returning a
flip.

The bottom of the figure defines function ‚∏®‚Äπnstep‚Ä∫(N,œÇ)‚∏©. It composes ‚∏®N‚∏©
invocations of ‚∏®‚Äπstep‚Ä∫‚∏© starting at ‚∏®œÇ‚∏© to produce a distribution of traces ‚∏®t‚∏©.

Both ‚∏®‚Äπstep‚Ä∫‚∏© and ‚∏®‚Äπnstep‚Ä∫‚∏© are \emph{partial} in the usual way:
They are undefined (``stuck'') for nonsensical programs like
‚∏®‚¶ëlocv‚¶í(Œπ) (‚¶ëbitv‚¶í‚∏§‚Ñì‚∏•(b))‚∏© (treating a reference location as if it were
a function). The \obliv type system, explained next, rejects
such programs while also ensuring~\nameref{thm:obliv-pmto}.

\FigureOblivTypes{fig:obliv-types}{\obliv type system.}

\subsection{Type System}
\label{subsec:obliv-design-types}

Figure~\ref{fig:obliv-types} defines the type system for \obliv source programs
as rules for judgment ‚∏®Œì ‚ä¢ e ‚¶Ç œÑ ‚®ü Œì'‚∏©, which states that under type
environment ‚∏®Œì‚∏© expression ‚∏®e‚∏© has type ‚∏®œÑ‚∏©, and yields residual type
environment ‚∏®Œì‚Ä≤‚∏©. We discuss typing configurations, including non-source
program values, in the next section. Type environments map variables to either
types ‚∏®œÑ‚∏© or inaccessibility tags ‚∏®‚Ä¢‚∏©, which are used to enforce
affinity of flips. We discuss the three key features of the type
system---affinity, probability regions, and information flow
control---in turn.

\paragraph*{Affinity}
%
To enforce non-duplicability, when an affine variable is used by the
program, its type is removed from the residual
environment. Figure~\ref{fig:obliv-types} defines kinding metafunction ‚∏®ùí¶‚∏©
that assigns a type either the kind universal ‚∏®‚¶ëU‚¶í‚∏© (freely duplicatable) or
affine ‚∏®‚¶ë A ‚¶í‚∏© (non-duplicatable). Bits, functions, and references (but not
their contents, necessarily) are always universal,
and flips are always affine. A pair is considered affine if either of
its components is. Rule *‚¶óVarU‚¶ò in Figure~\ref{fig:obliv-types} types
universally-kinded variables; the output environment ‚∏®Œì‚∏© is the same
as the input environment. Rule *‚¶óVarA‚¶ò types an affine variable by
marking it ‚∏®‚Ä¢‚∏© in the output environment.

Rules *‚¶óCast-S‚¶ò and *‚¶óCast-P‚¶ò permit converting flips to bits
via the ‚∏®‚¶ëcast‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏© and ‚∏®‚¶ëcast‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏© coercions, respectively. The
first converts a ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£‚∏© to a ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢œÅ‚∏£‚∏© and does \emph{not} make
its argument inaccessible (it returns the original ‚∏®Œì‚∏©) while the
second converts to a ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏¢‚ä•‚∏£‚∏© and does make it inaccessible
(returning ‚∏®Œì'‚∏©). The type system is enforcing that any
random number is made adversary-visible at most once; secret copies
are allowed because they are never revealed.

References may contain affine values, but references themselves are
universal. Rather than track the affinity of aliased contents
specifically, the *‚¶óRead‚¶ò rule disallows reading out of a reference
cell whose contents are affine. Since the write operation returns the
\emph{old} contents of the cell, programs can see the existing
contents of any reference by first writing in a valid
replacement~\cite{Baker:1992:LLL:142137.142162}.

The *‚¶óFun‚¶ò rule ensures that no affine variables in the defining
context are consumed within the body of the function, i.e., they are
not captured by its closure. We write ‚∏®Œì‚äé[x‚Ü¶‚Äó, y‚Ü¶‚Äó ]‚∏© to split a
context into a part that binds ‚∏®x‚∏© and ‚∏®y‚∏© and a part ‚∏®Œì‚∏© that binds the rest;
the ‚∏®Œì‚∏© part is returned, dropping the ‚∏®x‚∏© and ‚∏®y‚∏©
bindings. Both *‚¶óLet‚¶ò and *‚¶óLet-Tup‚¶ò similarly remove their bound
variables.

Finally, note that different variables could be made inaccessible in
different branches of a conditional, so *‚¶óIf‚¶ò types each branch in the
same initial context, but then joins their the output contexts; if a
variable is made inaccessible by one branch, it will be inaccessible
in the joined environment. Contexts are joined pointwise, and the join of two
pointed types ‚∏®‚á°‚Ä¢œÑ‚ÇÅ ‚äî ‚á°‚Ä¢œÑ‚ÇÇ‚∏© is ‚∏®‚Ä¢‚∏© when either ‚∏®‚á°‚Ä¢œÑ·µ¢‚∏© is ‚∏®‚Ä¢‚∏©, the same as
‚∏®‚á°‚Ä¢œÑ·µ¢‚∏© when both ‚∏®‚á°‚Ä¢œÑ·µ¢‚∏© are equal and not ‚∏®‚Ä¢‚∏©, and undefined otherwise.

\paragraph*{Information flow}
%
The type system aims to ensure that bits ‚∏®b‚∏§‚Ñì‚∏•‚∏© whose security label
‚∏®‚Ñì‚∏© is secret ‚∏®‚ÄπS‚Ä∫‚∏© cannot be learned by an adversary. Bit types
‚∏®‚¶ëbit‚¶í‚∏§‚Ñì‚∏•‚∏¢œÅ‚∏£‚∏© include the security label ‚∏®‚Ñì‚∏©. The rules treat types
with different labels as distinct, preventing so-called \emph{explicit} flows. For
example, the *‚¶óWrite‚¶ò rule prevents assigning a secret bit (of type
‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢œÅ‚∏£‚∏©) to a reference whose type is
‚∏®‚¶ëref‚¶í(‚¶ëbit‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏¢œÅ‚∏£)‚∏©. Likewise, a function of type ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏¢œÅ‚∏£ ‚Üí
œÑ‚∏© cannot be called with an argument of type ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢œÅ‚∏£‚∏©, per the
*‚¶óApp‚¶ò rule. In our implementation we relax *‚¶óApp‚¶ò (but not *‚¶óWrite‚¶ò, due to
the invariance of reference types) to allow public bits
when secrets are expected; this is not done here just to keep things simpler.

The rules also aim to prevent \emph{implicit} information flows. A
typical static information flow type system~\cite{infoflow} would
require the type of the conditional's guard
to be less secret than the type of what it returns; e.g., the guard's
type could be ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢œÅ‚∏£‚∏© but only if the final type ‚∏®œÑ‚∏© is secret
too. However, in \obliv we must be more restrictive: rule *‚¶óIf‚¶ò
requires the guard to be public since the
adversary-visible execution trace reveals which branch is taken, and
thus the truth of the guard. Branching on secrets must be done via
a multiplexor. Notice that rule *‚¶óMux-Bit‚¶ò sets the label ‚∏®‚Ñì‚∏© of the
each element of the returned pair to be the join of the labels on the
guard and the remaining components. As such, if the guard was secret,
then the returned results will be.  The *‚¶óMux-Flip‚¶ò rule
always returns flips, which are invisible to the adversary, so the
guard can be secret or public.

\paragraph*{Probability regions.}
%
A probability region ‚∏®œÅ‚∏© appears on both ‚∏®‚¶ëbit‚¶í‚∏© and ‚∏®‚¶ëflip‚¶í‚∏©
types. The region is a static name for a collection of flip values and
secret bit values that may be derived from them. A flip value is
associated with a region ‚∏®œÅ‚∏© when it is created, per rule *‚¶óFlip‚¶ò. Rule
*‚¶óCast-S‚¶ò ascribes the region ‚∏®œÅ‚∏© from the input ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£‚∏© to the
output type ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢œÅ‚∏£‚∏©, tracking the flip value(s) from which the
secret bit value was possibly derived. Per rule *‚¶óBit‚¶ò, bit literals
have probability region ‚∏®‚ä•‚∏©, as do public bits produced by
‚∏®‚¶ëcast‚¶í‚∏§‚ÄπP‚Ä∫‚∏•‚∏©, per rule *‚¶óCast-P‚¶ò.

Regions form a join semi-lattice.
%
The type system maintains the invariant that flips at region ‚∏®œÅ‚∏© are
probabilistically independent of all secret bits in regions ‚∏®œÅ‚Ä≤‚∏© when
strictly ordered ‚∏®œÅ‚Ä≤ ‚äè œÅ‚∏©. Strict ordering is used because it is
¬´irreflexive¬ª and ¬´asymmetric¬ª. The semantic property of
interest‚Äîprobabilistic independence‚Äîis likewise irreflexive (except
for point distributions), and asymmetry restricts future mux operations
between values in one direction only; we say more below.

Consider the *‚¶óMux-Flip‚¶ò rule. If a secret
bit is typed at region ‚∏®œÅ‚ÇÅ‚∏© and a flip value at region ‚∏®œÅ‚ÇÇ‚∏©, and ‚∏®œÅ‚ÇÅ ‚´Ω‚äè œÅ‚ÇÇ‚∏©,
then it may be that the values are correlated, and a ‚∏®‚¶ëmux‚¶í‚∏© involving the
values may produce flips that are non-uniform.
Both the *‚¶óMux-Flip‚¶ò and *‚¶óMux-Bit‚¶ò rules return outputs whose region is the join
of the regions of all inputs, indicating that the result of the ‚∏®‚¶ëmux‚¶í‚∏© is only
independent of values that were jointly independent of each of its components.

Because freshly generated random bits are always independent of each other, the
programmer is free to choose any regions when generating them via ‚∏®‚¶ëflip‚¶í‚∏¢œÅ‚∏£()‚∏©
expressions. However, once chosen, the ordering establishes an invariant which
constrains the order in which mux operations can occur subsequently in the
program.
Let's look at how the type checker uses strict region ordering to accept and reject a safe and unsafe
multiplexor. The following code uses regions ‚∏®œÅ‚ÇÅ ‚äè œÅ‚ÇÇ‚∏©.
\begin{center}
\begin{tabular}{cc}
\begin{minipage}{0.35\textwidth}
\begin{lstlisting}[escapeinside={([}{])}]
let sx,sy = (flip([$^{\rho_1}$])(),flip([$^{\rho_2}$])())
let sk,_ = castS(sx) ([‚∏®¬ø‚∏©]) sx ([‚∏®‚óá‚∏©]) sy
\end{lstlisting}
{\small (a) Incorrect example}
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}[escapeinside={([}{])}]
 let sx = flip([$^{\rho_1}$])() in
 let sy,sz = castS(sx) ([‚∏®¬ø‚∏©]) flip([$^{\rho_2}$])() ([‚∏®‚óá‚∏©]) flip([$^{\rho_2}$])()
\end{lstlisting}
{\small (b) Correct example}
\end{minipage}
\end{tabular}
\end{center}
The type checker first ascribes types ‚∏®‚¶ëflip‚¶í‚∏¢{œÅ‚ÇÅ}‚∏£‚∏© and
‚∏®‚¶ëflip‚¶í‚∏¢{œÅ‚ÇÇ}‚∏£‚∏© to \code{sx} and \code{sy}, respectively, according to
rules *‚¶óLet-Tup‚¶ò, *‚¶óFlip‚¶ò, and *‚¶óTup‚¶ò. It uses *‚¶óCast-S‚¶ò to give
\code{castS(sx)} type ‚∏®‚¶ëbit‚¶í‚∏§‚ÄπS‚Ä∫‚∏•‚∏¢{œÅ‚ÇÅ}‚∏£‚∏© and leaves \code{sx}
accessible so that *‚¶óVarA‚¶ò can be used to give it and \code{sy} types
‚∏®‚¶ëflip‚¶í‚∏¢{œÅ‚ÇÅ}‚∏£‚∏© and ‚∏®‚¶ëflip‚¶í‚∏¢{œÅ‚ÇÇ}‚∏£‚∏©, respectively (then making them
inaccessible). Rule *‚¶óMux-Flip‚¶ò will now fail because the independence
conditions do not hold. In particular, the region ‚∏®œÅ‚ÇÅ‚∏© of the
guard is not strictly less than the region ‚∏®œÅ‚ÇÅ‚∏© of the second
argument, i.e., ‚∏®œÅ‚ÇÅ ‚´Ω‚äè œÅ‚ÇÅ‚∏©.
%
The program labeled (b) above is well-typed.
Here, the bit in
the guard has region ‚∏®œÅ‚ÇÅ‚∏©, the region of the two flips is ‚∏®œÅ‚ÇÇ‚∏© and ‚∏®œÅ‚ÇÅ
‚äè œÅ‚ÇÇ‚∏© as required by *‚¶óMux-Flip‚¶ò. It is easy
to see that both \code{sy} and
\code{sz} are uniformly distributed and independent of \code{sx}.

Rule *‚¶óXor-Flip‚¶ò permits xor'ing a secret with a flip, returning a
flip, as long as the secret's region and the flip's region are
well ordered, which preserves uniformity.

We might be tempted not to order regions but instead
maintain an invariant that flips and bits
in distinct regions are independent. This turns out to not work.
%
While at the outset a fresh flip value is independent of all other
values in the context of the program, the region ordering is needed to
ensure that multiplexor operations will only occur in ``one direction.''
{E.g.}, if two fresh flip values are created ‚∏®x = ‚¶ëflip‚¶í‚∏¢œÅ‚ÇÅ‚∏£()‚∏© and ‚∏®y
= ‚¶ëflip‚¶í‚∏¢œÅ‚ÇÇ‚∏£‚∏©, it is true that ‚∏®x‚∏© and ‚∏®y‚∏© are mutually independent. Thus it would
seem reasonable that ‚∏®‚¶ëcast‚¶í‚∏§S‚∏•(x) ¬ø y ‚óá ‚Ä¶‚∏© and
‚∏®‚¶ëcast‚¶í‚∏§S‚∏•(y) ¬ø x ‚óá ‚Ä¶‚∏© should both be well typed. While they are
both safe in isolation, the combination is problematic. Consider the
results of each mux---they are both flip values, and they are both
valid to reveal using ‚∏®‚¶ëcast‚¶í‚∏§P‚∏•‚∏© individually. However, the resulting
values are correlated (revealing one tells you information about the
distribution of the other), which violates the uniformity guarantee of
all ‚∏®‚¶ëcast‚¶í‚∏§P‚∏•‚∏© results. By ordering the regions, we are essentially
promising to only allow ‚¶ëmux‚¶í operations like this in one direction
but not the other, and therefore uniformity is never violated for
revealed flip values. For example, by requiring ‚∏®œÅ‚ÇÅ ‚äè œÅ‚ÇÇ‚∏© we allow the
first multiplexor above but not the second.

\paragraph*{Type safety}

\obliv is type safe in the traditional sense, i.e., that a well-typed
program will not get stuck. However, our interest is in the stronger
property that type-safe \obliv programs do not reveal secret
information via inferences an adversary can draw from observing their
execution. We state and prove this stronger property in the next section.

\FigureOblivObs{fig:obliv-obs}{\obliv adversary observability.}

\subsection{Probabilistic Memory Trace Obliviousness}
\label{subsec:obliv-design-pmto}

The main metatheoretic result of this chapter is that \obliv's type
system ensures probabilistic memory trace obliviousness (PMTO). This
section defines the property, but does not go into details on the proof.

\Cref{fig:obliv-obs} presents a model ‚∏®‚Äπobs‚Ä∫‚∏© of the adversary's view of
a computation as a new class of values,
expressions and traces that ``hide'' sub-expressions
considered to be secret (written ‚∏®‚Ä¢‚∏©).  Secret bit expressions, secret bit values, and secret flip
values all map to ‚∏®‚Ä¢‚∏©. Compound values, expressions, stores, traces etc. call ‚∏®‚Äπobs‚Ä∫‚∏© in recursive
positions as expected.

Probabilistic memory trace obliviousness (PMTO), stated formally
below, holds when observationally equivalent configurations induce
distributions of traces that are themselves observationally equivalent
after $N$ steps, for any $N$.\footnote{Noninterference
  properties are often stated with a non-empty store.
  Our notion of expression equivalence is simpler, and supports
  low-equivalent expressions that pre-populate such a
  store, so there is no loss of generality.}
\begin{proposition}[PMTO]\label{thm:obliv-pmto}
  J‚ÅÖ If: ‚∏®e‚ÇÅ‚∏© and ‚∏®e‚ÇÇ‚∏© are closed source expressions, ‚∏®‚ä¢ e‚ÇÅ ‚¶Ç œÑ‚∏©, ‚∏®‚ä¢ e‚ÇÇ ‚¶Ç œÑ‚∏© and ‚∏®‚Äπobs‚Ä∫(e‚ÇÅ) = ‚Äπobs‚Ä∫(e‚ÇÇ)‚∏©
  J‚ÅÉ Then: (1) ‚∏®‚Äπnstep‚Ä∫(N,e‚ÇÅ)‚∏© and ‚∏®‚Äπnstep‚Ä∫(N,e‚ÇÇ)‚∏© are defined
  J‚ÅÉ And: (2) ‚∏®‚á°~*{‚Äπobs‚Ä∫}(‚Äπnstep‚Ä∫(N,e‚ÇÅ)) = ‚á°~*{‚Äπobs‚Ä∫}(‚Äπnstep‚Ä∫(N,e‚ÇÇ))‚∏©.
  J‚ÅÜ
\end{proposition}
\noindent
(1) ensures that information is not leaked due to lack of progress, {i.e.}, if
either program gets ‚Äústuck,‚Äù and that the main property (2) applies to all
related, well-typed source expressions ‚∏®e‚ÇÅ‚∏© and ‚∏®e‚ÇÇ‚∏©.

\section{Implementation}
\label{sec:obliv-impl}

We have implemented an interpreter and type checker for \textsc{OblivML},  a language that extends \obliv in
several (straightforward) ways.
%
First, we add natural number literals and random values; these can be
  encoded in \obliv as fixed-width tuples of ‚∏®‚¶ëbitv‚¶í‚∏© and ‚∏®‚¶ëflipv‚¶í‚∏©
  respectively. We write them annotated with a security level, e.g.,
  \code{2 S} or \code{2 P}, and write \code{rnd R ()} to generate a
  random number at region \code{R}. We write \code{natS} to be the
  type of a secret number in region ‚∏®‚ä•‚∏©; \code{natP} for the type of a
  public number; \code{R natS} for the type of a secret number in the
  region \code{R}.  We also write \code{R rnd} to be the
  type of a random natural number in the region \code{R}.
Second, we add arrays; in our code examples, we write
  \code{a[n]} and \code{a[n] <- e} to read and write array
  elements. An array of length $N$ can be encoded in \lang as
  an $N$-tuple of references, using nested conditional expressions to
  access the correct (public) index and swapping out affine
  contents, as must be done with references.
Finally, we add records, which are like tuples but permit field accessor
  notation, \code{r.x}; if \code{x} is affine, doing so only consumes the field \code{x}
rather than consuming all of \code{r}.

To demonstrate the expressiveness of \obliv, we used our interpreter to
program (and type check) a series of interesting oblivious
algorithms. We have implemented a modern \emph{non-recursive, tree-based ORAM} (NORAM), which
is a key component of state-of-the-art ORAM implementations~\cite{asiacrypt11,pathoram,circuitoram}.
To our knowledge, ours is the first implementation automatically verified to
be oblivious. Building on this NORAM, we also implemented a full \emph{recursive} ORAM.
Type checking it requires some advanced (but standard) language features we
have not implemented, including region polymorphism, recursive and variant
types, and existential quantification. Finally, we have implemented \emph{oblivious stacks}
(ostacks), a kind of oblivious data structure~\cite{ods} that builds on top of NORAM.
In doing so, we discovered that oblivious stacks are cryptographically secure, but merely
statistically secure~\cite{sweet-plas21}. They actually do leak information, but the security claim is the
amount of leakage is negligible. Our implementation and all the examples discussed can be
found online at \url{https://github.com/plum-umd/oblivml}.
