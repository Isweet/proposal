\chapter{The GMW Protocol}
\label{ch:gmw}

MPC works by allowing a secret, in cleartext, to be split up into many ``shares'' which are considered ciphertext
and therefore may be safely distributed to other parties and recombined later. More specifically, shares have the following properties:
\begin{enumerate}
\item Shares can be combined to reveal the original cleartext secret.
\item A share does not reveal any information about the secret.
\item Parties can cooperate to compute over shares. For example, being able to create shares of boolean values
  and compute XOR and AND over those shares forms a complete basis for computation. Primitives such as addition,
  comparison, etc. can be built from these boolean operations.
\end{enumerate}

The languages discussed in this proposal are agnostic to the underlying MPC protocol. We only require that the underlying MPC protocol
have the properties listed above. For the purposes of exposition, however, we choose to use the GMW protocol~\cite{10.1145/28395.28420} as a
representative for MPC protocols in general.

In GMW, the secrets being shared are booleans. To represent integers with arithmetic, comparison, etc. we use a two's
complement representation. For example, a digital circuit with only XOR and AND gates can be used to half adders,
full-adders, and ripple-carry adders. A party \alice can generate her share of her (boolean) secret \aliceSec by
generating a random number:

M‚ÅÖ
\aliceSh{\aliceSec} ‚Üê ùí∞(‚ù¥0,1‚ùµ)
M‚ÅÜ

The notation ‚∏®‚åäv‚åã‚∏§P‚∏•‚∏© indicates that this is ‚∏®P‚∏©'s share of the value ‚∏®v‚∏©. Then, \alice generates \bob's share of \aliceSec
as the XOR of her share with the original secret:

M‚ÅÖ
\bobSh{\aliceSec} ‚Üê \aliceSh{\aliceSec} ‚äï \aliceSec
M‚ÅÜ

At this point, there are a few important things to notice. First, \bob's share is effectively another random number.
As long as he never sees \aliceSh{\aliceSec} he can't distinguish his share \bobSh{\aliceSec} from a fresh, uniform
boolean value. This establishes property (2) of MPC above. Second, XOR has the following properties:

\begin{fact}[‚∏®‚äï‚∏©-Assoc]
\label{fact:xor-assoc}
  ‚∏®‚àÄ b‚ÇÅ,b‚ÇÇ,b‚ÇÉ ‚àà ùîπ‚ê£.‚ê£(b‚ÇÅ ‚äï b‚ÇÇ) ‚äï b‚ÇÉ = b‚ÇÅ ‚äï (b‚ÇÇ ‚äï b‚ÇÉ)‚∏©
\end{fact}

\begin{fact}[‚∏®‚äï‚∏©-Inverse]
\label{fact:xor-inverse}
  ‚∏®‚àÄ b ‚àà ùîπ‚ê£.‚ê£b ‚äï b = 0‚∏©
\end{fact}

\begin{fact}[‚∏®‚äï‚∏©-Identity]
\label{fact:xor-identity}
  ‚∏®‚àÄ b ‚àà ùîπ‚ê£.‚ê£b ‚äï 0 = 0 ‚äï b = b‚∏©
\end{fact}

These two properties ensure that the original secret, \aliceSec, can be recovered by XOR'ing the shares together:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚ßº=‚ßΩ \aliceSh{\aliceSec} ‚äï \aliceSh{\aliceSec} ‚äï \aliceSec & ‚ê†‚üÖ Definition of \bobSh{\aliceSec} ‚üÜ
  A‚ÅÉ                                         ‚ßº=‚ßΩ 0 ‚äï \aliceSec & ‚ê†‚üÖ \nameref{fact:xor-inverse} ‚üÜ
  A‚ÅÉ                                         ‚ßº=‚ßΩ \aliceSec & ‚ê†‚üÖ \nameref{fact:xor-identity} ‚üÜ
  A‚ÅÜ
M‚ÅÜ

which establishes MPC property (1) above. Now, let's assume that \bob executes the same protocol to share his secret, \bobSec,
with \alice by splitting it into \aliceSh{\bobSec} and \bobSh{\bobSec}. So, at this point \alice has her shares of both secrets
and similarly for \bob. How can we accomplish property (3) of MPC? To compute ‚∏®\aliceSec ‚äï \bobSec‚∏© we can simply have \alice and \bob
evaluate the XOR of their shares independently:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{A‚∏® \aliceSec ‚äï \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \aliceSh{\aliceSec} ‚äï \aliceSh{\bobSec}
  A‚ÅÉ \bobSh{A‚∏® \aliceSec   ‚äï \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \bobSh{\aliceSec}   ‚äï \bobSh{\bobSec}
  A‚ÅÜ
M‚ÅÜ

Why does this work? Well, it's because XOR is associative:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec ‚äï \bobSec} ‚äï \bobSh{\aliceSec ‚äï \bobSec} ‚ßº=‚ßΩ
    (\aliceSh{\aliceSec} ‚äï \aliceSh{\bobSec}) ‚äï (\bobSh{\aliceSec} ‚äï \bobSh{\bobSec}) & ‚ê†‚üÖ Definition of \aliceSh{A‚∏® \aliceSec ‚äï \bobSec A‚∏©} and \bobSh{A‚∏® \aliceSec   ‚äï \bobSec A‚∏©} ‚üÜ
  A‚ÅÉ ‚ßº=‚ßΩ
  (\aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec}) ‚äï (\aliceSh{\bobSec} ‚äï \bobSh{\bobSec}) & ‚ê†‚üÖ \nameref{fact:xor-assoc} ‚üÜ
  A‚ÅÉ ‚ßº=‚ßΩ
      \aliceSec ‚äï \bobSec & ‚ê†‚üÖ Share Recovery ‚üÜ
  A‚ÅÜ
M‚ÅÜ

Now for the tricky bit. How do we compute ‚∏®\aliceSec ‚àß \bobSec‚∏©? To describe this gate we assume that we have access to a
protocol called 1-4 Oblivious Transfer (OT). This protocol allows a sender, ‚∏®S‚∏©, to send 4 messages to a receiver, ‚∏®R‚∏©, in such a
way that (a) ‚∏®R‚∏© is only allowed to see 1 of the 4 messages and (b) ‚∏®S‚∏© cannot tell which message ‚∏®R‚∏© chose.

Assuming that we have access to such a protocol, we can compute \alice's share of the AND very simply:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \alices{œÉ}                          ‚ßº‚Üê‚ßΩ ùí∞(‚ù¥0,1‚ùµ)
  A‚ÅÉ \aliceSh{A‚∏® \aliceSec ‚àß \bobSec A‚∏©} ‚ßº‚Üê‚ßΩ \alices{œÉ}
  A‚ÅÜ
M‚ÅÜ

Now, we still need to figure out how \bob will compute his share of the AND. This will involve the 1-4 OT protocol in which \alice is the
sender and \bob is the receiver. Consider Table~\ref{tab:and-ot}, which is constructed by \alice. Each row indicates one of the possible
outcomes for \bob's shares, \bobSh{\aliceSec} and \bobSh{\bobSec}.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    \bobSh{\aliceSec} & \bobSh{\bobSec} & A‚∏® \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚àß \aliceSh{\bobSec} ‚äï \bobSh{\bobSec} A‚∏© & ‚∏®r‚∏© \\ \hline
    ‚∏®0‚∏© & ‚∏®0‚∏© & A‚∏® Œ±‚∏§0,0‚∏• = \aliceSh{\aliceSec} ‚äï 0 ‚àß \aliceSh{\bobSec} ‚äï 0 A‚∏© & A‚∏® r‚∏§0,0‚∏• = \alices{œÉ} ‚äï Œ±‚∏§0,0‚∏• A‚∏© \\ \hline
    ‚∏®0‚∏© & ‚∏®1‚∏© & A‚∏® Œ±‚∏§0,1‚∏• = \aliceSh{\aliceSec} ‚äï 0 ‚àß \aliceSh{\bobSec} ‚äï 1 A‚∏© & A‚∏® r‚∏§0,1‚∏• = \alices{œÉ} ‚äï Œ±‚∏§0,1‚∏• A‚∏© \\ \hline
    ‚∏®1‚∏© & ‚∏®0‚∏© & A‚∏® Œ±‚∏§1,0‚∏• = \aliceSh{\aliceSec} ‚äï 1 ‚àß \aliceSh{\bobSec} ‚äï 0 A‚∏© & A‚∏® r‚∏§1,0‚∏• = \alices{œÉ} ‚äï Œ±‚∏§1,0‚∏• A‚∏© \\ \hline
    ‚∏®1‚∏© & ‚∏®1‚∏© & A‚∏® Œ±‚∏§1,1‚∏• = \aliceSh{\aliceSec} ‚äï 1 ‚àß \aliceSh{\bobSec} ‚äï 1 A‚∏© & A‚∏® r‚∏§1,1‚∏• = \alices{œÉ} ‚äï Œ±‚∏§1,1‚∏• A‚∏© \\ \hline
  \end{tabular}
  \label{tab:and-ot}
\end{table}

If \alice now sends ‚∏®(r‚∏§0,0‚∏•,‚ê£r‚∏§0,1‚∏•,‚ê£r‚∏§1,0‚∏•,‚ê£r‚∏§1,1‚∏•)‚∏© via 1-4 OT to \bob, then \bob can select the message which corresponds the outcome
of his shares. For example, if \bob's shares are ‚∏®\bobSh{\aliceSec} = \bobSh{\bobSec} = 0‚∏© then he would select ‚∏®r‚∏§0,0‚∏•‚∏© (corresponding
to the first row in Table~\ref{tab:and-ot}).

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \bobSh{\aliceSec ‚àß \bobSec} ‚ßº‚Üê‚ßΩ r‚ê£‚Äπwhere‚Ä∫‚ê£& r = r‚∏§0,0‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 0‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 0
  A‚ÅÉ & & & r = r‚∏§0,1‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 0‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 1
  A‚ÅÉ & & & r = r‚∏§1,0‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 1‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 0
  A‚ÅÉ & & & r = r‚∏§1,1‚∏•‚ê£‚Äπif‚Ä∫‚ê£\bobSh{\aliceSec} = 1‚ê£‚Äπand‚Ä∫‚ê£\bobSh{\bobSec} = 1
  A‚ÅÜ
M‚ÅÜ

Finally, let's check that this is correct and secure. First, correctness:

M‚ÅÖ
  AÀêllll
  A‚ÅÖ \aliceSh{\aliceSec ‚àß \bobSec} ‚äï \bobSh{\aliceSec ‚àß \bobSec} ‚ßº=‚ßΩ \alices{œÉ} ‚äï (\alices{œÉ} ‚äï Œ±‚∏§i,j‚∏•) & ‚ê†‚üÖ Definition of ‚∏®‚àß‚∏© ‚üÜ
  A‚ÅÉ & & ‚Äπwhere‚Ä∫‚ê£i = \bobSh{\aliceSec}‚ê£‚Äπand‚Ä∫‚ê£j = \bobSh{\bobSec}
  A‚ÅÉ ‚ßº=‚ßΩ Œ±‚∏§i,j‚∏• & ‚ê†‚üÖ \nameref{fact:xor-assoc},~\nameref{fact:xor-inverse},~\nameref{fact:xor-identity} ‚üÜ
  A‚ÅÉ ‚ßº=‚ßΩ \aliceSh{\aliceSec} ‚äï \bobSh{\aliceSec} ‚àß \aliceSh{\bobSec} ‚äï \bobSh{\bobSec} & ‚ê†‚üÖ Definition of OT (Table~\ref{tab:and-ot}) ‚üÜ
  A‚ÅÉ ‚ßº=‚ßΩ \aliceSec ‚àß \bobSec & ‚ê†‚üÖ Share Recovery ‚üÜ
  A‚ÅÜ
M‚ÅÜ

Now, why is this secure? The security relies crucially on the properties of 1-4 OT. If \alice could tell which message \bob chose she would
immediately learn the values of \bob's shares and be able to recover \bob's secret. However, 1-4 OT guarantees that \alice cannot tell
which message \bob chose. Likewise, if \bob were able to see more than one of the messages sent by \alice then ‚∏®Œ± ‚äï \alices{œÉ}‚∏© would not
sufficiently protect ‚∏®Œ±‚∏©\footnote{More formally, the XOR with a random value forms a one-time pad (OTP) encryption scheme, which is only secure
  if the key is never reused.}. However, 1-4 OT guarantees that \bob can only see the message that he chooses.
