@inproceedings{sweet20odsnotpmto,
  title = {Short Paper: Probabilistically Almost-Oblivious Computation},
  author = {Ian Sweet and David Darais and Michael Hicks},
  booktitle = {Proceedings of the {ACM SIGPLAN} Workshop on Programming Languages and Analysis for Security (PLAS)},
  year = 2020,
  month = nov
}

@INPROCEEDINGS{gradual-release,
  author={Askarov, Aslan and Sabelfeld, Andrei},
  booktitle={2007 IEEE Symposium on Security and Privacy (SP '07)},
  title={Gradual Release: Unifying Declassification, Encryption and Key Release Policies},
  year={2007},
  volume={},
  number={},
  pages={207-221},
  doi={10.1109/SP.2007.22}}

@InProceedings{obliv-quicksort,
author="Hamada, Koki
and Kikuchi, Ryo
and Ikarashi, Dai
and Chida, Koji
and Takahashi, Katsumi",
editor="Kwon, Taekyoung
and Lee, Mun-Kyu
and Kwon, Daesung",
title="Practically Efficient Multi-party Sorting Protocols from Comparison Sort Algorithms",
booktitle="Information Security and Cryptology -- ICISC 2012",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="202--216",
abstract="Sorting is one of the most important primitives in various systems, for example, database systems, since it is often the dominant operation in the running time of an entire system. Therefore, there is a long list of work on improving its efficiency. It is also true in the context of secure multi-party computation (MPC), and several MPC sorting protocols have been proposed. However, all existing MPC sorting protocols are based on less efficient sorting algorithms, and the resultant protocols are also inefficient. This is because only a method for converting data-oblivious algorithms to corresponding MPC protocols is known, despite the fact that most efficient sorting algorithms such as quicksort and merge sort are not data-oblivious. We propose a simple and general approach of converting non-data-oblivious comparison sort algorithms, which include the above algorithms, into corresponding MPC protocols. We then construct an MPC sorting protocol from the well known efficient sorting algorithm, quicksort, with our approach. The resultant protocol is practically efficient since it significantly improved the running time compared to existing protocols in experiments.",
isbn="978-3-642-37682-5"
}

@InProceedings{USENIX:MNPS04,
  author =       "Dahlia Malkhi and
                  Noam Nisan and
                  Benny Pinkas and
                  Yaron Sella",
  title =        "Fairplay - Secure Two-Party Computation System",
  pages =        "287--302",
  editor =       usenix04ed,
  booktitle =    usenix04name,
  address =      usenix04addr,
  month =        usenix04month,
  publisher =    usenixpub,
  year =         2004,
}

@InProceedings{CCS:AFLNO16,
  author =       "Toshinori Araki and
                  Jun Furukawa and
                  Yehuda Lindell and
                  Ariel Nof and
                  Kazuma Ohara",
  title =        "High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority",
  pages =        "805--817",
  editor =       ccs16ed,
  booktitle =    ccs16name,
  address =      ccs16addr,
  month =        ccs16month,
  publisher =    ccspub,
  year =         2016,
  doi =          "10.1145/2976749.2978331",
}

@InProceedings{CCS:ZhaSteBla13,
  author =       "Yihua Zhang and
                  Aaron Steele and
                  Marina Blanton",
  title =        "{PICCO}: a general-purpose compiler for private distributed computation",
  pages =        "813--826",
  editor =       ccs13ed,
  booktitle =    ccs13name,
  address =      ccs13addr,
  month =        ccs13month,
  publisher =    ccspub,
  year =         2013,
  doi =          "10.1145/2508859.2516752",
}

@InProceedings{ESORICS:BogLauWil08,
  author =       "Dan Bogdanov and
                  Sven Laur and
                  Jan Willemson",
  title =        "Sharemind: A Framework for Fast Privacy-Preserving Computations",
  pages =        "192--206",
  editor =       esorics08ed,
  booktitle =    esorics08name,
  volume =       esorics08vol,
  address =      esorics08addr,
  month =        esorics08month,
  publisher =    esoricspub,
  series =       mylncs,
  year =         2008,
  doi =          "10.1007/978-3-540-88313-5_13",
}

@InProceedings{CCS:BDKKS18,
  author =       "Niklas B{\"u}scher and
                  Daniel Demmler and
                  Stefan Katzenbeisser and
                  David Kretzmer and
                  Thomas Schneider",
  title =        "{HyCC}: Compilation of Hybrid Protocols for Practical Secure Computation",
  pages =        "847--861",
  editor =       ccs18ed,
  booktitle =    ccs18name,
  address =      ccs18addr,
  month =        ccs18month,
  publisher =    ccspub,
  year =         2018,
  doi =          "10.1145/3243734.3243786",
}

@misc{cryptoeprint:2018:707,
    author       = {Elette Boyle and
		    Niv Gilboa and
		    Yuval Ishai},
    title        = {Function Secret Sharing: Improvements and Extensions},
    howpublished = {Cryptology ePrint Archive, Report 2018/707},
    year         = {2018},
    note         = {\url{https://ia.cr/2018/707}},
}

@INPROCEEDINGS{7163030,
  author={Costello, Craig and Fournet, Cédric and Howell, Jon and Kohlweiss, Markulf and Kreuter, Benjamin and Naehrig, Michael and Parno, Bryan and Zahur, Samee},
  booktitle={2015 IEEE Symposium on Security and Privacy},
  title={Geppetto: Versatile Verifiable Computation},
  year={2015},
  volume={},
  number={},
  pages={253-270},
  doi={10.1109/SP.2015.23}}

@article{doi:10.1137/0218012,
author = {Goldwasser, Shafi and Micali, Silvio and Rackoff, Charles},
title = {The Knowledge Complexity of Interactive Proof Systems},
journal = {SIAM Journal on Computing},
volume = {18},
number = {1},
pages = {186-208},
year = {1989},
doi = {10.1137/0218012},
URL = {https://doi.org/10.1137/0218012},
eprint = {https://doi.org/10.1137/0218012}}


@unpublished{symphony22,
  author = {Ian Sweet and David Darais and David Heath and William Harris and Ryan Estes and Michael Hicks},
  title  = {SYMPHONY: Secure Multiparty Computation with Coordination},
  year   = 2021,
  URL    = {https://www.cs.umd.edu/~ins/symphony22.pdf}
}

@inproceedings{darais20obliv,
  title = {A Language for Probabilistically Oblivious Computation},
  booktitle = {Proceedings of the {ACM} Conference on Principles of Programming Languages (POPL)},
  author = {David Darais and Ian Sweet and Chang Liu and Michael Hicks},
  year = {2020},
  month = jan
}

@article{Sabelfeld2009DeclassificationDA,
  title={Declassification: Dimensions and principles},
  author={A. Sabelfeld and David Sands},
  journal={J. Comput. Secur.},
  year={2009},
  volume={17},
  pages={517-548}
}

@inproceedings{10.5555/1792734.1792766,
author = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
title = {Z3: An Efficient SMT Solver},
year = {2008},
isbn = {3540787992},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first
order formulas with respect to combinations of background theories such as: arithmetic,
bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver
freely available from Microsoft Research. It is used in various software verification
and analysis applications.},
booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
pages = {337–340},
numpages = {4},
location = {Budapest, Hungary},
series = {TACAS'08/ETAPS'08}
}

@InProceedings{10.1007/978-3-642-31424-7_64,
author="Hoffmann, Jan
and Aehlig, Klaus
and Hofmann, Martin",
editor="Madhusudan, P.
and Seshia, Sanjit A.",
title="Resource Aware ML",
booktitle="Computer Aided Verification",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="781--786",
abstract="The automatic determination of the quantitative resource consumption of programs is a classic research topic which has many applications in software development. Recently, we developed a novel multivariate amortized resource analysis that automatically computes polynomial resource bounds for first-order functional programs.",
isbn="978-3-642-31424-7"
}

@inproceedings{10.5555/3310435.3310585,
author = {Chan, T-H. Hubert and Chung, Kai-Min and Maggs, Bruce M. and Shi, Elaine},
title = {Foundations of Differentially Oblivious Algorithms},
year = {2019},
publisher = {Society for Industrial and Applied Mathematics},
address = {USA},
abstract = {It is well-known that a program's memory access pattern can leak information about
its input. To thwart such leakage, most existing works adopt the technique of oblivious
RAM (ORAM) simulation. Such an obliviousness notion has stimulated much debate. Although
ORAM techniques have significantly improved over the past few years, the concrete
overheads are arguably still undesirable for real-world systems --- part of this overhead
is in fact inherent due to a well-known logarithmic ORAM lower bound by Goldreich
and Ostrovsky. To make matters worse, when the program's runtime or output length
depend on secret inputs, it may be necessary to perform worst-case padding to achieve
full obliviousness and thus incur possibly super-linear overheads.Inspired by the
elegant notion of differential privacy, we initiate the study of a new notion of access
pattern privacy, which we call "(ϵ, δ)-differential obliviousness". We separate the
notion of (ϵ, δ)-differential obliviousness from classical obliviousness by considering
several fundamental algorithmic abstractions including sorting small-length keys,
merging two sorted lists, and range query data structures (akin to binary search trees).
We show that by adopting differential obliviousness with reasonable choices of ϵ and
δ, not only can one circumvent several impossibilities pertaining to full obliviousness,
one can also, in several cases, obtain meaningful privacy with little overhead relative
to the non-private baselines (i.e., having privacy "almost for free"). On the other
hand, we show that for very demanding choices of ϵ and δ, the same lower bounds for
oblivious algorithms would be preserved for (ϵ, δ)-differential obliviousness.},
booktitle = {Proceedings of the Thirtieth Annual ACM-SIAM Symposium on Discrete Algorithms},
pages = {2448–2467},
numpages = {20},
location = {San Diego, California},
series = {SODA '19}
}

@inbook{10.1145/3133956.3133967,
author = {Doerner, Jack and Shelat, Abhi},
title = {Scaling ORAM for Secure Computation},
year = {2017},
isbn = {9781450349468},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3133956.3133967},
abstract = {We design and implement a Distributed Oblivious Random Access Memory (DORAM) data
structure that is optimized for use in two-party secure computation protocols. We
improve upon the access time of previous constructions by a factor of up to ten, their
memory overhead by a factor of one hundred or more, and their initialization time
by a factor of thousands. We are able to instantiate ORAMs that hold 234 bytes, and
perform operations on them in seconds, which was not previously feasible with any
implemented scheme.Unlike prior ORAM constructions based on hierarchical hashing,
permutation, or trees, our Distributed ORAM is derived from the new Function Secret
Sharing scheme introduced by Boyle, Gilboa and Ishai. This significantly reduces the
amount of secure computation required to implement an ORAM access, albeit at the cost
of O(n) efficient local memory operations.We implement our construction and find that,
despite its poor O(n) asymptotic complexity, it still outperforms the fastest previously
known constructions, Circuit ORAM and Square-root ORAM, for datasets that are 32 KiB
or larger, and outperforms prior work on applications such as stable matching or binary
search by factors of two to ten.},
booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
pages = {523–535},
numpages = {13}
}

@inproceedings{10.1145/28395.28420,
author = {Goldreich, O. and Micali, S. and Wigderson, A.},
title = {How to Play ANY Mental Game},
year = {1987},
isbn = {0897912217},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/28395.28420},
doi = {10.1145/28395.28420},
abstract = {We present a polynomial-time algorithm that, given as a input the description of a
game with incomplete information and any number of players, produces a protocol for
playing the game that leaks no partial information, provided the majority of the players
is honest.Our algorithm automatically solves all the multi-party protocol problems
addressed in complexity-based cryptography during the last 10 years. It actually is
a completeness theorem for the class of distributed protocols with honest majority.
Such completeness theorem is optimal in the sense that, if the majority of the players
is not honest, some protocol problems have no efficient solution [C].},
booktitle = {Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing},
pages = {218–229},
numpages = {12},
location = {New York, New York, USA},
series = {STOC '87}
}